const express = require('express');
const sqlite3 = require('sqlite3').verbose();
const path = require('path');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const session = require('express-session');
const rateLimit = require('express-rate-limit');
const crypto = require('crypto');
const nodemailer = require('nodemailer');

const app = express();
const PORT = process.env.PORT || 3000;

// JWT Secret (in production, use environment variable)
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-this-in-production';

// Rate limiting
const loginLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Increased to 100 attempts per window for testing
    message: 'Too many login attempts, please try again later.',
    standardHeaders: true,
    legacyHeaders: false,
});

// Middleware
app.use(cors({
    origin: 'http://localhost:3000',
    credentials: true
}));
app.use(express.json());
app.use(express.static('.'));

// Session configuration
app.use(session({
    secret: JWT_SECRET,
    resave: false,
    saveUninitialized: false,
    cookie: {
        secure: false, // Set to true in production with HTTPS
        httpOnly: true,
        maxAge: 24 * 60 * 60 * 1000 // 24 hours
    }
}));

// Initialize SQLite database
const db = new sqlite3.Database('./locations.db');

// Create tables if they don't exist
db.serialize(() => {
    // Users table
    db.run(`
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT UNIQUE NOT NULL,
            email TEXT UNIQUE NOT NULL,
            password_hash TEXT NOT NULL,
            first_name TEXT,
            last_name TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            is_active BOOLEAN DEFAULT 1,
            reset_token TEXT,
            reset_token_expires DATETIME,
            email_verified BOOLEAN DEFAULT 0,
            verification_token TEXT,
            verification_token_expires DATETIME,
            is_admin BOOLEAN DEFAULT 0
        )
    `);

    // Saved locations table
    db.run(`
        CREATE TABLE IF NOT EXISTS saved_locations (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            place_id TEXT UNIQUE NOT NULL,
            name TEXT NOT NULL,
            address TEXT,
            lat REAL NOT NULL,
            lng REAL NOT NULL,
            rating REAL,
            website TEXT,
            photo_url TEXT,
            saved_count INTEGER DEFAULT 1,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `);
    
    // User saves table (updated to reference users table)
    db.run(`
        CREATE TABLE IF NOT EXISTS user_saves (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            place_id TEXT NOT NULL,
            saved_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
            FOREIGN KEY (place_id) REFERENCES saved_locations (place_id) ON DELETE CASCADE
        )
    `);
});

// Authentication middleware
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
        return res.status(401).json({ error: 'Access token required' });
    }

    jwt.verify(token, JWT_SECRET, (err, user) => {
        if (err) {
            return res.status(403).json({ error: 'Invalid or expired token' });
        }
        req.user = user;
        next();
    });
};

// Optional authentication middleware (for endpoints that work with or without auth)
const optionalAuth = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (token) {
        jwt.verify(token, JWT_SECRET, (err, user) => {
            if (!err) {
                req.user = user;
            }
        });
    }
    next();
};

// Admin authorization middleware
const requireAdmin = (req, res, next) => {
    if (!req.user) {
        return res.status(401).json({ error: 'Authentication required' });
    }
    
    if (!req.user.isAdmin) {
        return res.status(403).json({ error: 'Admin privileges required' });
    }
    
    next();
};

// Generate simple user ID (keep for backward compatibility)
function generateUserId() {
    return 'user_' + Math.random().toString(36).substr(2, 9);
}

// Password validation
function validatePassword(password) {
    const minLength = 8;
    const hasUpperCase = /[A-Z]/.test(password);
    const hasLowerCase = /[a-z]/.test(password);
    const hasNumbers = /\d/.test(password);
    const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);

    const errors = [];
    if (password.length < minLength) errors.push('Password must be at least 8 characters long');
    if (!hasUpperCase) errors.push('Password must contain at least one uppercase letter');
    if (!hasLowerCase) errors.push('Password must contain at least one lowercase letter');
    if (!hasNumbers) errors.push('Password must contain at least one number');
    if (!hasSpecialChar) errors.push('Password must contain at least one special character');

    return {
        isValid: errors.length === 0,
        errors: errors
    };
}

// Email validation with enhanced regex and domain checking
function validateEmail(email) {
    // Enhanced email regex pattern
    const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    
    if (!emailRegex.test(email)) {
        return { isValid: false, error: 'Invalid email format' };
    }
    
    // Check email length
    if (email.length > 254) {
        return { isValid: false, error: 'Email address is too long' };
    }
    
    // Check for common invalid patterns
    const invalidPatterns = [
        /\.\./,  // consecutive dots
        /^\./, // starts with dot
        /\.$/, // ends with dot
        /@\./,  // @ followed by dot
        /\.@/   // dot followed by @
    ];
    
    for (const pattern of invalidPatterns) {
        if (pattern.test(email)) {
            return { isValid: false, error: 'Invalid email format' };
        }
    }
    
    // Check for common disposable email domains (optional)
    const disposableEmailDomains = [
        '10minutemail.com',
        'guerrillamail.com',
        'mailinator.com',
        'tempmail.org',
        'throwaway.email'
    ];
    
    const domain = email.split('@')[1]?.toLowerCase();
    if (disposableEmailDomains.includes(domain)) {
        return { isValid: false, error: 'Disposable email addresses are not allowed' };
    }
    
    return { isValid: true };
}

// Email service configuration
const emailConfig = {
    service: 'gmail', // You can change this to your email service
    auth: {
        user: process.env.EMAIL_USER || 'your-email@gmail.com',
        pass: process.env.EMAIL_PASS || 'your-app-password'
    }
};

// Create nodemailer transporter
let emailTransporter = null;

// Initialize email transporter (will be disabled if no config)
try {
    if (process.env.EMAIL_USER && process.env.EMAIL_PASS) {
        emailTransporter = nodemailer.createTransport(emailConfig);
    }
} catch (error) {
    console.log('Email service not configured. Email verification will be disabled.');
}

// Generate verification token
function generateVerificationToken() {
    return crypto.randomBytes(32).toString('hex');
}

// Send verification email
async function sendVerificationEmail(email, username, token) {
    if (!emailTransporter) {
        console.log(`Email verification disabled. Verification token for ${email}: ${token}`);
        console.log(`Verification URL: http://localhost:3000/verify-email.html?token=${token}`);
        return true;
    }
    
    const verificationUrl = `http://localhost:3000/verify-email.html?token=${token}`;
    
    const mailOptions = {
        from: emailConfig.auth.user,
        to: email,
        subject: 'Verify Your Email - Map Search App',
        html: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                <h2 style="color: #1a73e8;">Welcome to Map Search App!</h2>
                <p>Hello ${username},</p>
                <p>Thank you for registering with Map Search App. To complete your registration, please verify your email address by clicking the button below:</p>
                <div style="text-align: center; margin: 30px 0;">
                    <a href="${verificationUrl}" style="background-color: #1a73e8; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
                        Verify Email Address
                    </a>
                </div>
                <p>If the button doesn't work, you can copy and paste this link into your browser:</p>
                <p style="word-break: break-all; color: #666;">${verificationUrl}</p>
                <p>This verification link will expire in 24 hours.</p>
                <p>If you didn't create an account with us, please ignore this email.</p>
                <hr style="border: none; border-top: 1px solid #eee; margin: 30px 0;">
                <p style="font-size: 12px; color: #666;">This is an automated message, please do not reply to this email.</p>
            </div>
        `
    };
    
    try {
        await emailTransporter.sendMail(mailOptions);
        return true;
    } catch (error) {
        console.error('Error sending verification email:', error);
        return false;
    }
}

// Authentication Routes

// Register new user
app.post('/api/auth/register', async (req, res) => {
    try {
        const { username, email, password, firstName, lastName } = req.body;

        // Validate input
        if (!username || !email || !password) {
            return res.status(400).json({ error: 'Username, email, and password are required' });
        }

        // Enhanced email validation
        const emailValidation = validateEmail(email);
        if (!emailValidation.isValid) {
            return res.status(400).json({ error: emailValidation.error });
        }

        // Password validation
        const passwordValidation = validatePassword(password);
        if (!passwordValidation.isValid) {
            return res.status(400).json({ error: passwordValidation.errors.join(', ') });
        }

        // Check if user already exists
        const existingUser = await new Promise((resolve, reject) => {
            db.get('SELECT id FROM users WHERE username = ? OR email = ?', [username, email], (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });

        if (existingUser) {
            return res.status(409).json({ error: 'Username or email already exists' });
        }

        // Hash password
        const saltRounds = 12;
        const passwordHash = await bcrypt.hash(password, saltRounds);

        // Generate verification token
        const verificationToken = generateVerificationToken();
        const verificationTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

        // Create user
        const userId = await new Promise((resolve, reject) => {
            db.run(
                'INSERT INTO users (username, email, password_hash, first_name, last_name, verification_token, verification_token_expires) VALUES (?, ?, ?, ?, ?, ?, ?)',
                [username, email, passwordHash, firstName || null, lastName || null, verificationToken, verificationTokenExpires.toISOString()],
                function(err) {
                    if (err) reject(err);
                    else resolve(this.lastID);
                }
            );
        });

        // Send verification email
        const emailSent = await sendVerificationEmail(email, username, verificationToken);
        
        if (!emailSent && emailTransporter) {
            // If email service is configured but failed to send, return error
            return res.status(500).json({ error: 'Failed to send verification email. Please try again.' });
        }

        // Generate JWT token (user can use the app but with limited access until verified)
        const token = jwt.sign(
            { userId: userId, username: username, email: email, verified: false },
            JWT_SECRET,
            { expiresIn: '24h' }
        );

        res.status(201).json({
            success: true,
            message: emailTransporter 
                ? 'User registered successfully. Please check your email to verify your account.'
                : 'User registered successfully. Email verification is disabled in development.',
            token: token,
            user: {
                id: userId,
                username: username,
                email: email,
                firstName: firstName,
                lastName: lastName,
                emailVerified: false
            },
            requiresVerification: !!emailTransporter
        });

    } catch (error) {
        console.error('Registration error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Login user
app.post('/api/auth/login', loginLimiter, async (req, res) => {
    try {
        const { username, password } = req.body;

        if (!username || !password) {
            return res.status(400).json({ error: 'Username and password are required' });
        }

        // Get user from database
        const user = await new Promise((resolve, reject) => {
            db.get(
                'SELECT id, username, email, password_hash, first_name, last_name, is_active, email_verified, is_admin FROM users WHERE username = ? OR email = ?',
                [username, username],
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                }
            );
        });

        if (!user) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        if (!user.is_active) {
            return res.status(401).json({ error: 'Account is deactivated' });
        }

        // Check password
        const passwordMatch = await bcrypt.compare(password, user.password_hash);
        if (!passwordMatch) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        // Generate JWT token
        const token = jwt.sign(
            { 
                userId: user.id, 
                username: user.username, 
                email: user.email,
                verified: user.email_verified,
                isAdmin: Boolean(user.is_admin)
            },
            JWT_SECRET,
            { expiresIn: '24h' }
        );

        res.json({
            success: true,
            message: 'Login successful',
            token: token,
            user: {
                id: user.id,
                username: user.username,
                email: user.email,
                firstName: user.first_name,
                lastName: user.last_name,
                emailVerified: user.email_verified,
                isAdmin: Boolean(user.is_admin)
            }
        });

    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Get user profile
app.get('/api/auth/profile', authenticateToken, (req, res) => {
    db.get(
        'SELECT id, username, email, first_name, last_name, email_verified, created_at, is_admin FROM users WHERE id = ?',
        [req.user.userId],
        (err, row) => {
            if (err) {
                return res.status(500).json({ error: err.message });
            }
            if (!row) {
                return res.status(404).json({ error: 'User not found' });
            }
            res.json({
                success: true,
                user: {
                    id: row.id,
                    username: row.username,
                    email: row.email,
                    firstName: row.first_name,
                    lastName: row.last_name,
                    emailVerified: row.email_verified,
                    createdAt: row.created_at,
                    isAdmin: Boolean(row.is_admin)
                }
            });
        }
    );
});

// Verify token validity
app.get('/api/auth/verify', authenticateToken, (req, res) => {
    db.get(
        'SELECT id, username, email, first_name, last_name, email_verified, created_at, is_admin FROM users WHERE id = ?',
        [req.user.userId],
        (err, row) => {
            if (err) {
                return res.status(500).json({ error: err.message });
            }
            if (!row) {
                return res.status(401).json({ error: 'User not found', success: false });
            }
            
            // Return success and user data
            res.json({
                success: true,
                user: {
                    id: row.id,
                    username: row.username,
                    email: row.email,
                    firstName: row.first_name,
                    lastName: row.last_name,
                    emailVerified: Boolean(row.email_verified),
                    createdAt: row.created_at,
                    isAdmin: Boolean(row.is_admin)
                }
            });
        }
    );
});

// Update user profile
app.put('/api/auth/profile', authenticateToken, async (req, res) => {
    try {
        const { firstName, lastName, email } = req.body;
        const userId = req.user.userId;

        // Enhanced email validation
        if (email) {
            const emailValidation = validateEmail(email);
            if (!emailValidation.isValid) {
                return res.status(400).json({ error: emailValidation.error });
            }
        }

        // Check if email is already used by another user
        if (email) {
            const existingUser = await new Promise((resolve, reject) => {
                db.get('SELECT id FROM users WHERE email = ? AND id != ?', [email, userId], (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                });
            });

            if (existingUser) {
                return res.status(409).json({ error: 'Email already in use' });
            }
        }

        // Get current user email to check if it's changing
        const currentUser = await new Promise((resolve, reject) => {
            db.get('SELECT email FROM users WHERE id = ?', [userId], (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });

        const emailChanged = email && email !== currentUser.email;
        let verificationToken = null;
        let verificationTokenExpires = null;

        // If email is changing, generate new verification token
        if (emailChanged) {
            verificationToken = generateVerificationToken();
            verificationTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours
        }

        // Update user
        await new Promise((resolve, reject) => {
            const query = emailChanged 
                ? 'UPDATE users SET first_name = ?, last_name = ?, email = ?, email_verified = 0, verification_token = ?, verification_token_expires = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?'
                : 'UPDATE users SET first_name = ?, last_name = ?, email = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?';
            
            const params = emailChanged 
                ? [firstName || null, lastName || null, email, verificationToken, verificationTokenExpires.toISOString(), userId]
                : [firstName || null, lastName || null, email, userId];

            db.run(query, params, function(err) {
                if (err) reject(err);
                else resolve();
            });
        });

        // Send verification email if email changed
        if (emailChanged) {
            const emailSent = await sendVerificationEmail(email, req.user.username, verificationToken);
            
            if (!emailSent && emailTransporter) {
                return res.status(500).json({ error: 'Profile updated but failed to send verification email. Please try again.' });
            }
        }

        res.json({
            success: true,
            message: emailChanged 
                ? 'Profile updated successfully. Please verify your new email address.'
                : 'Profile updated successfully',
            emailChanged: emailChanged,
            requiresVerification: emailChanged && !!emailTransporter
        });

    } catch (error) {
        console.error('Profile update error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Change password
app.put('/api/auth/change-password', authenticateToken, async (req, res) => {
    try {
        const { currentPassword, newPassword } = req.body;
        const userId = req.user.userId;

        if (!currentPassword || !newPassword) {
            return res.status(400).json({ error: 'Current password and new password are required' });
        }

        const passwordValidation = validatePassword(newPassword);
        if (!passwordValidation.isValid) {
            return res.status(400).json({ error: passwordValidation.errors.join(', ') });
        }

        // Get current password hash
        const user = await new Promise((resolve, reject) => {
            db.get('SELECT password_hash FROM users WHERE id = ?', [userId], (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });

        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }

        // Check current password
        const passwordMatch = await bcrypt.compare(currentPassword, user.password_hash);
        if (!passwordMatch) {
            return res.status(401).json({ error: 'Current password is incorrect' });
        }

        // Hash new password
        const saltRounds = 12;
        const newPasswordHash = await bcrypt.hash(newPassword, saltRounds);

        // Update password
        await new Promise((resolve, reject) => {
            db.run(
                'UPDATE users SET password_hash = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
                [newPasswordHash, userId],
                function(err) {
                    if (err) reject(err);
                    else resolve();
                }
            );
        });

        res.json({
            success: true,
            message: 'Password changed successfully'
        });

    } catch (error) {
        console.error('Password change error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Request password reset
app.post('/api/auth/forgot-password', async (req, res) => {
    try {
        const { email } = req.body;

        if (!email) {
            return res.status(400).json({ error: 'Email is required' });
        }

        // Check if user exists
        const user = await new Promise((resolve, reject) => {
            db.get('SELECT id, username, email FROM users WHERE email = ?', [email], (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });

        if (!user) {
            // Don't reveal if email exists or not
            return res.json({
                success: true,
                message: 'If an account with that email exists, a password reset link has been sent.'
            });
        }

        // Generate reset token
        const resetToken = crypto.randomBytes(32).toString('hex');
        const resetTokenExpires = new Date(Date.now() + 3600000); // 1 hour

        // Save reset token
        await new Promise((resolve, reject) => {
            db.run(
                'UPDATE users SET reset_token = ?, reset_token_expires = ? WHERE id = ?',
                [resetToken, resetTokenExpires.toISOString(), user.id],
                function(err) {
                    if (err) reject(err);
                    else resolve();
                }
            );
        });

        // In a real app, you would send an email here
        console.log(`Password reset token for ${email}: ${resetToken}`);
        console.log(`Reset URL: http://localhost:3000/reset-password.html?token=${resetToken}`);

        res.json({
            success: true,
            message: 'If an account with that email exists, a password reset link has been sent.',
            // In development, include the token for testing
            resetToken: resetToken
        });

    } catch (error) {
        console.error('Password reset request error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Reset password
app.post('/api/auth/reset-password', async (req, res) => {
    try {
        const { token, newPassword } = req.body;

        if (!token || !newPassword) {
            return res.status(400).json({ error: 'Token and new password are required' });
        }

        const passwordValidation = validatePassword(newPassword);
        if (!passwordValidation.isValid) {
            return res.status(400).json({ error: passwordValidation.errors.join(', ') });
        }

        // Find user with valid reset token
        const user = await new Promise((resolve, reject) => {
            db.get(
                'SELECT id, username, email FROM users WHERE reset_token = ? AND reset_token_expires > ?',
                [token, new Date().toISOString()],
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                }
            );
        });

        if (!user) {
            return res.status(400).json({ error: 'Invalid or expired reset token' });
        }

        // Hash new password
        const saltRounds = 12;
        const newPasswordHash = await bcrypt.hash(newPassword, saltRounds);

        // Update password and clear reset token
        await new Promise((resolve, reject) => {
            db.run(
                'UPDATE users SET password_hash = ?, reset_token = NULL, reset_token_expires = NULL, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
                [newPasswordHash, user.id],
                function(err) {
                    if (err) reject(err);
                    else resolve();
                }
            );
        });

        res.json({
            success: true,
            message: 'Password reset successfully'
        });

    } catch (error) {
        console.error('Password reset error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Verify email
app.post('/api/auth/verify-email', async (req, res) => {
    try {
        const { token } = req.body;

        if (!token) {
            return res.status(400).json({ error: 'Verification token is required' });
        }

        // Find user with valid verification token
        const user = await new Promise((resolve, reject) => {
            db.get(
                'SELECT id, username, email, email_verified FROM users WHERE verification_token = ? AND verification_token_expires > ?',
                [token, new Date().toISOString()],
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                }
            );
        });

        if (!user) {
            return res.status(400).json({ error: 'Invalid or expired verification token' });
        }

        if (user.email_verified) {
            return res.status(400).json({ error: 'Email is already verified' });
        }

        // Mark email as verified and clear verification token
        await new Promise((resolve, reject) => {
            db.run(
                'UPDATE users SET email_verified = 1, verification_token = NULL, verification_token_expires = NULL, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
                [user.id],
                function(err) {
                    if (err) reject(err);
                    else resolve();
                }
            );
        });

        res.json({
            success: true,
            message: 'Email verified successfully'
        });

    } catch (error) {
        console.error('Email verification error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Resend verification email
app.post('/api/auth/resend-verification', async (req, res) => {
    try {
        const { email } = req.body;

        if (!email) {
            return res.status(400).json({ error: 'Email is required' });
        }

        // Find user by email
        const user = await new Promise((resolve, reject) => {
            db.get(
                'SELECT id, username, email, email_verified FROM users WHERE email = ?',
                [email],
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                }
            );
        });

        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }

        if (user.email_verified) {
            return res.status(400).json({ error: 'Email is already verified' });
        }

        // Generate new verification token
        const verificationToken = generateVerificationToken();
        const verificationTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

        // Update user with new verification token
        await new Promise((resolve, reject) => {
            db.run(
                'UPDATE users SET verification_token = ?, verification_token_expires = ? WHERE id = ?',
                [verificationToken, verificationTokenExpires.toISOString(), user.id],
                function(err) {
                    if (err) reject(err);
                    else resolve();
                }
            );
        });

        // Send verification email
        const emailSent = await sendVerificationEmail(user.email, user.username, verificationToken);
        
        if (!emailSent && emailTransporter) {
            return res.status(500).json({ error: 'Failed to send verification email. Please try again.' });
        }

        res.json({
            success: true,
            message: emailTransporter 
                ? 'Verification email sent successfully'
                : 'Verification email would be sent (disabled in development)'
        });

    } catch (error) {
        console.error('Resend verification error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// API Routes

// Get all saved locations (public)
app.get('/api/locations', (req, res) => {
    const query = `
        SELECT 
            place_id,
            name,
            address,
            lat,
            lng,
            rating,
            website,
            photo_url,
            saved_count,
            created_at
        FROM saved_locations 
        ORDER BY saved_count DESC, created_at DESC
    `;
    
    db.all(query, [], (err, rows) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        res.json(rows);
    });
});

// Get user's saved locations (updated for authenticated users)
app.get('/api/user/locations', authenticateToken, (req, res) => {
    const userId = req.user.userId;
    
    const query = `
        SELECT 
            sl.place_id,
            sl.name,
            sl.address,
            sl.lat,
            sl.lng,
            sl.rating,
            sl.website,
            sl.photo_url,
            us.saved_at
        FROM saved_locations sl
        JOIN user_saves us ON sl.place_id = us.place_id
        WHERE us.user_id = ?
        ORDER BY us.saved_at DESC
    `;
    
    db.all(query, [userId], (err, rows) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        res.json(rows);
    });
});

// Legacy endpoint for backwards compatibility with anonymous users
app.get('/api/user/:userId/locations', (req, res) => {
    const { userId } = req.params;
    
    // If userId is numeric, it's a real user ID
    if (!isNaN(userId)) {
        const query = `
            SELECT 
                sl.place_id,
                sl.name,
                sl.address,
                sl.lat,
                sl.lng,
                sl.rating,
                sl.website,
                sl.photo_url,
                us.saved_at
            FROM saved_locations sl
            JOIN user_saves us ON sl.place_id = us.place_id
            WHERE us.user_id = ?
            ORDER BY us.saved_at DESC
        `;
        
        db.all(query, [userId], (err, rows) => {
            if (err) {
                res.status(500).json({ error: err.message });
                return;
            }
            res.json(rows);
        });
    } else {
        // For anonymous users, return empty array
        res.json([]);
    }
});

// Save a location for authenticated user
app.post('/api/user/locations', authenticateToken, (req, res) => {
    const { placeId, name, address, lat, lng, rating, website, photoUrl } = req.body;
    const userId = req.user.userId;

    // Validate required fields
    if (!placeId || !name || !lat || !lng) {
        return res.status(400).json({ error: 'placeId, name, lat, and lng are required' });
    }

    // Check if user has already saved this location
    db.get(
        'SELECT id FROM user_saves WHERE user_id = ? AND place_id = ?',
        [userId, placeId],
        (err, row) => {
            if (err) {
                return res.status(500).json({ error: err.message });
            }

            if (row) {
                return res.status(409).json({ error: 'Location already saved' });
            }

            // Insert or update location in saved_locations table
            db.run(
                `INSERT OR REPLACE INTO saved_locations 
                (place_id, name, address, lat, lng, rating, website, photo_url, saved_count, updated_at) 
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, 
                    COALESCE((SELECT saved_count FROM saved_locations WHERE place_id = ?), 0) + 1, 
                    CURRENT_TIMESTAMP)`,
                [placeId, name, address, lat, lng, rating, website, photoUrl, placeId],
                function(err) {
                    if (err) {
                        return res.status(500).json({ error: err.message });
                    }

                    // Add user save record
                    db.run(
                        'INSERT INTO user_saves (user_id, place_id) VALUES (?, ?)',
                        [userId, placeId],
                        function(err) {
                            if (err) {
                                return res.status(500).json({ error: err.message });
                            }
                            
                            res.json({
                                success: true,
                                message: 'Location saved successfully',
                                placeId: placeId
                            });
                        }
                    );
                }
            );
        }
    );
});

// Legacy endpoint for backwards compatibility
app.post('/api/locations', (req, res) => {
    const { userId, placeId, name, address, lat, lng, rating, website, photoUrl } = req.body;

    // If userId is numeric, it's a real user ID, require authentication
    if (userId && !isNaN(userId)) {
        return res.status(401).json({ error: 'Authentication required' });
    }

    // For anonymous users, just return success without saving
    res.json({
        success: true,
        message: 'Please log in to save locations',
        placeId: placeId
    });
});

// Remove a location for authenticated user
app.delete('/api/user/locations/:placeId', authenticateToken, (req, res) => {
    const { placeId } = req.params;
    const userId = req.user.userId;

    db.serialize(() => {
        // Remove user save record
        db.run(
            'DELETE FROM user_saves WHERE user_id = ? AND place_id = ?',
            [userId, placeId],
            function(err) {
                if (err) {
                    return res.status(500).json({ error: err.message });
                }

                if (this.changes === 0) {
                    return res.status(404).json({ error: 'Location not found for user' });
                }

                // Decrease saved count
                db.run(
                    'UPDATE saved_locations SET saved_count = saved_count - 1 WHERE place_id = ?',
                    [placeId],
                    function(err) {
                        if (err) {
                            return res.status(500).json({ error: err.message });
                        }

                        // Remove location if no one has saved it
                        db.run(
                            'DELETE FROM saved_locations WHERE place_id = ? AND saved_count <= 0',
                            [placeId],
                            function(err) {
                                if (err) {
                                    return res.status(500).json({ error: err.message });
                                }

                                res.json({
                                    success: true,
                                    message: 'Location removed successfully'
                                });
                            }
                        );
                    }
                );
            }
        );
    });
});

// Legacy endpoint for backwards compatibility
app.delete('/api/user/:userId/locations/:placeId', (req, res) => {
    const { userId, placeId } = req.params;

    // If userId is numeric, it's a real user ID, require authentication
    if (!isNaN(userId)) {
        return res.status(401).json({ error: 'Authentication required' });
    }

    // For anonymous users, just return success
    res.json({
        success: true,
        message: 'Please log in to manage saved locations'
    });
});

// Get popular locations
app.get('/api/locations/popular', (req, res) => {
    const query = `
        SELECT 
            place_id,
            name,
            address,
            lat,
            lng,
            rating,
            website,
            photo_url,
            saved_count,
            created_at
        FROM saved_locations 
        WHERE saved_count > 1
        ORDER BY saved_count DESC, created_at DESC
        LIMIT 20
    `;
    
    db.all(query, [], (err, rows) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }
        res.json(rows);
    });
});

// Generate user ID endpoint
app.get('/api/generate-user-id', (req, res) => {
    res.json({ userId: generateUserId() });
});

// Start server
app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
});

// Graceful shutdown
process.on('SIGINT', () => {
    console.log('Shutting down gracefully...');
    db.close((err) => {
        if (err) {
            console.error('Error closing database:', err.message);
        } else {
            console.log('Database connection closed.');
        }
        process.exit(0);
    });
});

// Admin Routes

// Get all users (admin only)
/*
app.get('/api/admin/users', authenticateToken, requireAdmin, (req, res) => {
    db.all(
        `SELECT 
            id, username, email, first_name, last_name, 
            email_verified, is_active, is_admin, 
            created_at, updated_at
        FROM users 
        ORDER BY created_at DESC`,
        [],
        (err, rows) => {
            if (err) {
                return res.status(500).json({ error: err.message });
            }
            
            // Return just the users array (NOT wrapped in success object)
            res.json(rows.map(user => ({
                id: user.id,
                username: user.username,
                email: user.email,
                first_name: user.first_name,
                last_name: user.last_name,
                email_verified: Boolean(user.email_verified),
                is_active: Boolean(user.is_active),
                is_admin: Boolean(user.is_admin),
                created_at: user.created_at,
                updated_at: user.updated_at
            )));
        }
    );
});
*/

// Get user details (admin only)
app.get('/api/admin/users/:userId', authenticateToken, requireAdmin, (req, res) => {
    const { userId } = req.params;
    
    db.get(
        `SELECT 
            id, username, email, first_name, last_name, 
            email_verified, is_active, is_admin, 
            created_at, updated_at
        FROM users 
        WHERE id = ?`,
        [userId],
        (err, user) => {
            if (err) {
                return res.status(500).json({ error: err.message });
            }
            
            if (!user) {
                return res.status(404).json({ error: 'User not found' });
            }
            
            // Get user's saved locations
            db.all(
                `SELECT 
                    sl.place_id,
                    sl.name,
                    sl.address,
                    sl.lat,
                    sl.lng,
                    sl.rating,
                    sl.website,
                    sl.photo_url,
                    us.saved_at
                FROM saved_locations sl
                JOIN user_saves us ON sl.place_id = us.place_id
                WHERE us.user_id = ?
                ORDER BY us.saved_at DESC`,
                [userId],
                (err, locations) => {
                    if (err) {
                        return res.status(500).json({ error: err.message });
                    }
                    
                    res.json({
                        success: true,
                        user: {
                            id: user.id,
                            username: user.username,
                            email: user.email,
                            firstName: user.first_name,
                            lastName: user.last_name,
                            emailVerified: Boolean(user.email_verified),
                            isActive: Boolean(user.is_active),
                            isAdmin: Boolean(user.is_admin),
                            createdAt: user.created_at,
                            updatedAt: user.updated_at
                        },
                        savedLocations: locations
                    });
                }
            );
        }
    );
});

// Update user (admin only)
app.put('/api/admin/users/:userId', authenticateToken, requireAdmin, async (req, res) => {
    const { userId } = req.params;
    const { firstName, lastName, email, isActive, isAdmin, emailVerified } = req.body;
    
    try {
        // Ensure the user exists
        const existingUser = await new Promise((resolve, reject) => {
            db.get('SELECT id FROM users WHERE id = ?', [userId], (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });
        
        if (!existingUser) {
            return res.status(404).json({ error: 'User not found' });
        }
        
        // Check if email already exists for another user
        if (email) {
            const emailUser = await new Promise((resolve, reject) => {
                db.get('SELECT id FROM users WHERE email = ? AND id != ?', [email, userId], (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                });
            });
            
            if (emailUser) {
                return res.status(409).json({ error: 'Email already in use by another user' });
            }
            
            // Validate email if provided
            const emailValidation = validateEmail(email);
            if (!emailValidation.isValid) {
                return res.status(400).json({ error: emailValidation.error });
            }
        }
        
        // Build update query
        const updateFields = [];
        const params = [];
        
        if (firstName !== undefined) {
            updateFields.push('first_name = ?');
            params.push(firstName || null);
        }
        
        if (lastName !== undefined) {
            updateFields.push('last_name = ?');
            params.push(lastName || null);
        }
        
        if (email !== undefined) {
            updateFields.push('email = ?');
            params.push(email);
        }
        
        if (isActive !== undefined) {
            updateFields.push('is_active = ?');
            params.push(isActive ? 1 : 0);
        }
        
        if (isAdmin !== undefined) {
            updateFields.push('is_admin = ?');
            params.push(isAdmin ? 1 : 0);
        }
        
        if (emailVerified !== undefined) {
            updateFields.push('email_verified = ?');
            params.push(emailVerified ? 1 : 0);
        }
        
        // Always update the updated_at timestamp
        updateFields.push('updated_at = CURRENT_TIMESTAMP');
        
        // If nothing to update, return early
        if (params.length === 0) {
            return res.status(400).json({ error: 'No fields to update' });
        }
        
        // Append user ID to params
        params.push(userId);
        
        // Update user
        await new Promise((resolve, reject) => {
            db.run(
                `UPDATE users SET ${updateFields.join(', ')} WHERE id = ?`,
                params,
                function(err) {
                    if (err) reject(err);
                    else resolve(this.changes);
                }
            );
        });
        
        res.json({
            success: true,
            message: 'User updated successfully'
        });
        
    } catch (error) {
        console.error('Admin user update error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Delete user (admin only)
app.delete('/api/admin/users/:userId', authenticateToken, requireAdmin, async (req, res) => {
    const { userId } = req.params;
    
    try {
        // Ensure the user exists
        const existingUser = await new Promise((resolve, reject) => {
            db.get('SELECT id FROM users WHERE id = ?', [userId], (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });
        
        if (!existingUser) {
            return res.status(404).json({ error: 'User not found' });
        }
        
        // Check if trying to delete self
        if (parseInt(userId) === req.user.userId) {
            return res.status(400).json({ error: 'Cannot delete your own account' });
        }
        
        // Start transaction
        db.serialize(() => {
            db.run('BEGIN TRANSACTION');
            
            // Delete user's saved locations references
            db.run('DELETE FROM user_saves WHERE user_id = ?', [userId], function(err) {
                if (err) {
                    db.run('ROLLBACK');
                    return res.status(500).json({ error: err.message });
                }
                
                // Delete the user
                db.run('DELETE FROM users WHERE id = ?', [userId], function(err) {
                    if (err) {
                        db.run('ROLLBACK');
                        return res.status(500).json({ error: err.message });
                    }
                    
                    db.run('COMMIT');
                    res.json({
                        success: true,
                        message: 'User deleted successfully'
                    });
                });
            });
        });
        
    } catch (error) {
        console.error('Admin user delete error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Admin reset user password
app.post('/api/admin/users/:userId/reset-password', authenticateToken, requireAdmin, async (req, res) => {
    const { userId } = req.params;
    const { newPassword } = req.body;
    
    try {
        // Validate input
        if (!newPassword) {
            return res.status(400).json({ error: 'New password is required' });
        }
        
        // Validate password
        const passwordValidation = validatePassword(newPassword);
        if (!passwordValidation.isValid) {
            return res.status(400).json({ error: passwordValidation.errors.join(', ') });
        }
        
        // Ensure the user exists
        const existingUser = await new Promise((resolve, reject) => {
            db.get('SELECT id FROM users WHERE id = ?', [userId], (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });
        
        if (!existingUser) {
            return res.status(404).json({ error: 'User not found' });
        }
        
        // Hash password
        const saltRounds = 12;
        const passwordHash = await bcrypt.hash(newPassword, saltRounds);
        
        // Update user's password
        await new Promise((resolve, reject) => {
            db.run(
                'UPDATE users SET password_hash = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
                [passwordHash, userId],
                function(err) {
                    if (err) reject(err);
                    else resolve(this.changes);
                }
            );
        });
        
        res.json({
            success: true,
            message: 'User password reset successfully'
        });
        
    } catch (error) {
        console.error('Admin password reset error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Admin location management

// Get all locations (admin only)
app.get('/api/admin/locations', authenticateToken, requireAdmin, (req, res) => {
    db.all(
        `SELECT 
            place_id, name, address, lat, lng, 
            rating, website, photo_url, saved_count,
            created_at, updated_at
        FROM saved_locations 
        ORDER BY saved_count DESC, created_at DESC`,
        [],
        (err, locations) => {
            if (err) {
                return res.status(500).json({ error: err.message });
            }
            
            res.json({
                success: true,
                locations: locations
            });
        }
    );
});

// Delete location (admin only)
app.delete('/api/admin/locations/:placeId', authenticateToken, requireAdmin, (req, res) => {
    const { placeId } = req.params;
    
    db.serialize(() => {
        db.run('BEGIN TRANSACTION');
        
        // Delete all user saves for this location
        db.run('DELETE FROM user_saves WHERE place_id = ?', [placeId], function(err) {
            if (err) {
                db.run('ROLLBACK');
                return res.status(500).json({ error: err.message });
            }
            
            // Delete the location
            db.run('DELETE FROM saved_locations WHERE place_id = ?', [placeId], function(err) {
                if (err) {
                    db.run('ROLLBACK');
                    return res.status(500).json({ error: err.message });
                }
                
                if (this.changes === 0) {
                    db.run('ROLLBACK');
                    return res.status(404).json({ error: 'Location not found' });
                }
                
                db.run('COMMIT');
                res.json({
                    success: true,
                    message: 'Location deleted successfully'
                });
            });
        });
    });
});

// Get admin statistics (admin only)
app.get('/api/admin/stats', authenticateToken, requireAdmin, (req, res) => {
    console.log('📊 Admin stats endpoint called');
    
    // Get total users count
    db.get('SELECT COUNT(*) as totalUsers FROM users', [], (err, userCount) => {
        if (err) {
            console.error('Error getting user count:', err);
            return res.status(500).json({ error: err.message });
        }
        
        // Get admin users count
        db.get('SELECT COUNT(*) as adminUsers FROM users WHERE is_admin = 1', [], (err, adminCount) => {
            if (err) {
                console.error('Error getting admin count:', err);
                return res.status(500).json({ error: err.message });
            }
            
            // Get total locations count
            db.get('SELECT COUNT(*) as totalLocations FROM saved_locations', [], (err, locationCount) => {
                if (err) {
                    console.error('Error getting location count:', err);
                    return res.status(500).json({ error: err.message });
                }
                
                // Get active sessions (simplified - users updated in last 24h)
                db.get(`
                    SELECT COUNT(*) as activeSessions 
                    FROM users 
                    WHERE updated_at > datetime('now', '-1 day')
                `, [], (err, sessionCount) => {
                    if (err) {
                        console.error('Error getting session count:', err);
                        return res.status(500).json({ error: err.message });
                    }
                    
                    const stats = {
                        totalUsers: userCount.totalUsers,
                        adminUsers: adminCount.adminUsers,
                        totalLocations: locationCount.totalLocations,
                        activeSessions: sessionCount.activeSessions
                    };
                    
                    console.log('📊 Returning stats:', stats);
                    res.json(stats);
                });
            });
        });
    });
});

// Promote/demote user role (admin only)
app.put('/api/admin/users/:userId/role', authenticateToken, requireAdmin, async (req, res) => {
    const { userId } = req.params;
    const { action } = req.body; // 'promote' or 'demote'
    
    try {
        // Ensure the user exists
        const existingUser = await new Promise((resolve, reject) => {
            db.get('SELECT id, is_admin FROM users WHERE id = ?', [userId], (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });
        
        if (!existingUser) {
            return res.status(404).json({ error: 'User not found' });
        }
        
        // Check if trying to modify self
        if (parseInt(userId) === req.user.userId) {
            return res.status(400).json({ error: 'Cannot modify your own admin status' });
        }
        
        // Determine new admin status
        const newAdminStatus = action === 'promote' ? 1 : 0;
        
        // Update user's admin status
        await new Promise((resolve, reject) => {
            db.run(
                'UPDATE users SET is_admin = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
                [newAdminStatus, userId],
                function(err) {
                    if (err) reject(err);
                    else resolve(this.changes);
                }
            );
        });
        
        res.json({
            success: true,
            message: `User ${action}d successfully`
        });
        
    } catch (error) {
        console.error(`Admin user ${action} error:`, error);
        res.status(500).json({ error: 'Internal server error' });
    }
});


