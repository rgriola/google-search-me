<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Click to Save Flow Test</title>
     <link rel="stylesheet" href="css/clickToSaveTest.css">
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div class="header">
                <h1>Click to Save Flow Test</h1>
                <p>Test the complete workflow from map click to database save</p>
            </div>
            
            <div class="controls">
                <div class="instructions">
                    <h4>üìã Test Instructions</h4>
                    <ol>
                        <li>First, login with your credentials</li>
                        <li>Click "Enable Click to Save" to activate the feature</li>
                        <li>Click anywhere on the map to place a marker</li>
                        <li>Fill out the location form and click "Save Location"</li>
                        <li>Verify the location appears in the sidebar</li>
                        <li>Check the debug log for detailed flow information</li>
                    </ol>
                </div>
                
                <button id="clickToSaveBtn" class="control-btn" onclick="toggleClickToSave()">
                    Enable Click to Save
                </button>
                <button class="control-btn" onclick="clearDebugLog()">
                    Clear Debug Log
                </button>
                <button class="control-btn" onclick="refreshLocations()">
                    Refresh Locations
                </button>
                <button class="control-btn" onclick="showDataReadout()">
                    Show Data Structure
                </button>
                
                <!-- Location Type Filters -->
                <div class="location-filters horizontal" style="padding: 12px 16px; background: #fff; border: 1px solid #e0e0e0; border-radius: 8px; margin: 12px 0; box-shadow: 0 2px 8px rgba(0,0,0,0.04);">
                    <h4 style="margin: 0 1rem 0 0; color: #333; font-size: 0.9rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; display: inline-block; vertical-align: middle;">Filter Types:</h4>
                    <div class="filter-options" style="display: flex; flex-direction: row; flex-wrap: wrap; gap: 0.75rem; align-items: center;">
                        <div class="filter-option" style="display: flex; align-items: center; gap: 0.35rem; cursor: pointer; padding: 0.25rem 0.5rem; border-radius: 6px; transition: background-color 0.2s ease; white-space: nowrap;">
                            <input type="checkbox" id="filter-live-reporter" value="live reporter" checked style="margin: 0; cursor: pointer;">
                            <label for="filter-live-reporter" class="filter-label" style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #555; cursor: pointer; flex: 1;">
                                <span class="type-marker" style="display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 20px; border-radius: 50%; color: white; font-size: 0.7rem; font-weight: bold; text-align: center; line-height: 1; background: #ff4444;">LR</span>
                                Live Reporter
                            </label>
                        </div>
                        <div class="filter-option" style="display: flex; align-items: center; gap: 0.35rem; cursor: pointer; padding: 0.25rem 0.5rem; border-radius: 6px; transition: background-color 0.2s ease; white-space: nowrap;">
                            <input type="checkbox" id="filter-live-anchor" value="live anchor" checked style="margin: 0; cursor: pointer;">
                            <label for="filter-live-anchor" class="filter-label" style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #555; cursor: pointer; flex: 1;">
                                <span class="type-marker" style="display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 20px; border-radius: 50%; color: white; font-size: 0.7rem; font-weight: bold; text-align: center; line-height: 1; background: #4285f4;">LA</span>
                                Live Anchor
                            </label>
                        </div>
                        <div class="filter-option" style="display: flex; align-items: center; gap: 0.35rem; cursor: pointer; padding: 0.25rem 0.5rem; border-radius: 6px; transition: background-color 0.2s ease; white-space: nowrap;">
                            <input type="checkbox" id="filter-stakeout" value="stakeout" checked style="margin: 0; cursor: pointer;">
                            <label for="filter-stakeout" class="filter-label" style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #555; cursor: pointer; flex: 1;">
                                <span class="type-marker" style="display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 20px; border-radius: 50%; color: white; font-size: 0.7rem; font-weight: bold; text-align: center; line-height: 1; background: #ffbb33;">ST</span>
                                Stakeout
                            </label>
                        </div>
                        <div class="filter-option" style="display: flex; align-items: center; gap: 0.35rem; cursor: pointer; padding: 0.25rem 0.5rem; border-radius: 6px; transition: background-color 0.2s ease; white-space: nowrap;">
                            <input type="checkbox" id="filter-interview" value="interview" checked style="margin: 0; cursor: pointer;">
                            <label for="filter-interview" class="filter-label" style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #555; cursor: pointer; flex: 1;">
                                <span class="type-marker" style="display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 20px; border-radius: 50%; color: white; font-size: 0.7rem; font-weight: bold; text-align: center; line-height: 1; background: #8e44ad;">IN</span>
                                Interview
                            </label>
                        </div>
                        <div class="filter-option" style="display: flex; align-items: center; gap: 0.35rem; cursor: pointer; padding: 0.25rem 0.5rem; border-radius: 6px; transition: background-color 0.2s ease; white-space: nowrap;">
                            <input type="checkbox" id="filter-broll" value="broll" checked style="margin: 0; cursor: pointer;">
                            <label for="filter-broll" class="filter-label" style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #555; cursor: pointer; flex: 1;">
                                <span class="type-marker" style="display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 20px; border-radius: 50%; color: white; font-size: 0.7rem; font-weight: bold; text-align: center; line-height: 1; background: #ad1457;">BR</span>
                                B-Roll
                            </label>
                        </div>
                        <div style="margin-left: 1rem;">
                            <button onclick="toggleAllFilters()" style="padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Toggle All</button>
                            <span id="filter-stats" style="margin-left: 10px; font-size: 12px; color: #666;">All types visible</span>
                        </div>
                    </div>
                </div>
                
                <!-- Clustering Controls -->
                <div class="clustering-controls" style="padding: 8px 16px; background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 8px; margin: 8px 0; box-shadow: 0 1px 4px rgba(0,0,0,0.03);">
                    <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
                        <h4 style="margin: 0; color: #333; font-size: 0.85rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">üîó Clustering:</h4>
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.85rem; color: #555;">
                            <input type="checkbox" id="clustering-enabled" checked onchange="toggleClustering()" style="margin: 0; cursor: pointer;">
                            Enable Marker Clustering
                        </label>
                        <span id="cluster-stats" style="font-size: 12px; color: #666; margin-left: auto;">Clustering active</span>
                    </div>
                </div>
            </div>
            
            <div class="map-container">
                <div class="map-controls">
                    <div id="mapStatus" class="control-btn">
                        Click to Save: Disabled
                    </div>
                </div>
                <div id="map"></div>
            </div>
        </div>
        
        <div class="sidebar">
            <!-- Authentication Section -->
            <div class="auth-section">
                <h3>üîê Authentication</h3>
                <form onsubmit="event.preventDefault(); login();">
                    <input type="email" id="email" placeholder="Email" value="rodczaro@gmail.com">
                    <input type="password" id="password" placeholder="Password">
                    <button type="submit">Login</button>
                </form>
                <div id="authStatus" class="auth-status" style="display: none;"></div>
            </div>
            
            <!-- Locations Section -->
            <div class="locations-section">
                <h3>üìç Saved Locations</h3>
                <div id="savedLocationsList" class="saved-locations-list">
                    <div class="no-locations">
                        <p>No saved locations yet</p>
                        <p>Click on the map to save a location</p>
                    </div>
                </div>
            </div>
            
            <!-- Debug Log Section -->
            <div class="debug-section">
                <h3>üîç Debug Log</h3>
                <div id="debugLog" class="debug-log">
                    <div class="debug-entry info">Debug log initialized</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Save Location Modal -->
    <div id="saveLocationModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Save Location</h2>
                <span class="close" onclick="closeSaveModal()">&times;</span>
            </div>
            
            <form id="saveLocationForm">
                <div class="address-display" id="locationAddress">
                    Address will appear here...
                </div>
                
                <!-- Name Field - Required, defaults to street + city -->
                <div class="form-group">
                    <label for="locationName">Location Name *</label>
                    <input type="text" id="locationName" name="name" required maxlength="100" placeholder="Will default to street + city">
                </div>
                
                <!-- Address Components - User can edit before save -->
                <div class="form-group">
                    <label for="locationNumber">Street Number</label>
                    <input type="text" id="locationNumber" name="number" placeholder="3375">
                </div>
                
                <div class="form-group">
                    <label for="locationStreet">Street</label>
                    <input type="text" id="locationStreet" name="street" placeholder="Laren Lane Southwest">
                </div>
                
                <div class="form-group">
                    <label for="locationCity">City</label>
                    <input type="text" id="locationCity" name="city" placeholder="Atlanta">
                </div>
                
                <div class="form-group">
                    <label for="locationState">State</label>
                    <input type="text" id="locationState" name="state" maxlength="2" placeholder="GA">
                </div>
                
                <div class="form-group">
                    <label for="locationZipcode">Zip Code</label>
                    <input type="text" id="locationZipcode" name="zipcode" maxlength="5" placeholder="30311">
                </div>
                
                <!-- Production Notes -->
                <div class="form-group">
                    <label for="productionNotes">Production Notes</label>
                    <textarea id="productionNotes" name="production_notes" maxlength="200" placeholder="Additional notes about this location..." rows="3"></textarea>
                    <small class="char-count">0/200 characters</small>
                </div>
                
                <!-- Type - Required dropdown -->
                <div class="form-group">
                    <label for="locationType">Type *</label>
                    <select id="locationType" name="type" required>
                        <option value="">Select type...</option>
                        <option value="broll">B-Roll</option>
                        <option value="interview">Interview</option>
                        <option value="live anchor">Live Anchor</option>
                        <option value="live reporter">Live Reporter</option>
                        <option value="stakeout">Stakeout</option>
                    </select>
                </div>
                
                <!-- Entry Point -->
                <div class="form-group">
                    <label for="entryPoint">Entry Point</label>
                    <select id="entryPoint" name="entry_point">
                        <option value="">Select entry point...</option>
                        <option value="front door">Front Door</option>
                        <option value="backdoor">Back Door</option>
                        <option value="garage">Garage</option>
                        <option value="parking lot">Parking Lot</option>
                    </select>
                </div>
                
                <!-- Parking -->
                <div class="form-group">
                    <label for="parking">Parking</label>
                    <select id="parking" name="parking">
                        <option value="">Select parking...</option>
                        <option value="street">Street</option>
                        <option value="driveway">Driveway</option>
                        <option value="garage">Garage</option>
                    </select>
                </div>
                
                <!-- Access -->
                <div class="form-group">
                    <label for="access">Access</label>
                    <select id="access" name="access">
                        <option value="">Select access...</option>
                        <option value="ramp">Ramp</option>
                        <option value="stairs only">Stairs Only</option>
                        <option value="doorway">Doorway</option>
                        <option value="garage">Garage</option>
                    </select>
                </div>

                <!-- Photo Upload Section -->
                <div class="form-group">
                    <div class="photo-section">
                        <button type="button" class="photo-toggle-btn" onclick="togglePhotoUpload('save')">
                            <span class="toggle-text">Add Photos</span> üì∏
                        </button>
                        
                        <div id="save-photo-upload" class="photo-upload-section" style="display: none;">
                            <div class="photo-drop-zone" 
                                 ondragover="handleDragOver(event)" 
                                 ondragleave="handleDragLeave(event)" 
                                 ondrop="handlePhotoDrop(event, 'save')">
                                <input type="file" id="save-photo-input" multiple accept="image/*" 
                                       onchange="handlePhotoFile(event, 'save')" style="display: none;">
                                <div class="drop-zone-content" onclick="document.getElementById('save-photo-input').click()">
                                    <div class="upload-icon">üì∑</div>
                                    <div class="upload-text">Click or drag photos here</div>
                                    <div class="upload-hint">JPEG, PNG, WebP (max 10MB each)</div>
                                </div>
                            </div>
                            <div id="save-photo-preview" class="photo-preview-container"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Hidden fields for coordinates and place_id -->
                <input type="hidden" id="locationLat" name="lat">
                <input type="hidden" id="locationLng" name="lng">
                <input type="hidden" id="locationPlaceId" name="place_id">
                <input type="hidden" id="formattedAddress" name="formatted_address">
                
                <div class="form-actions">
                    <button type="button" class="btn-secondary" onclick="closeSaveModal()">Cancel</button>
                    <button type="submit" class="btn-primary">Save Location</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Photo Modal -->
    <div id="photoModal" class="photo-modal" onclick="closePhotoModal()">
        <div class="photo-modal-content" onclick="event.stopPropagation()">
            <button class="photo-modal-close" onclick="closePhotoModal()">&times;</button>
            <img id="photoModalImage" src="" alt="Photo">
            <div class="photo-modal-info">
                <div class="photo-modal-caption" id="photoModalCaption"></div>
                <div class="photo-modal-meta" id="photoModalMeta"></div>
            </div>
        </div>
    </div>

    <!-- Load Google Maps API -->
    <script>
        // Google Maps API error handler
        window.gm_authFailure = function() {
            debugLog('Google Maps API authentication failed', 'error');
            alert('Google Maps API authentication failed. Please check the API key.');
        };
        
        // Check if Google Maps is available
        function checkGoogleMaps() {
            if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
                debugLog('Google Maps API not loaded', 'error');
                setTimeout(checkGoogleMaps, 1000); // Check again in 1 second
                return;
            }
            debugLog('Google Maps API loaded successfully', 'success');
        }
        
        // Start checking after a short delay
        setTimeout(checkGoogleMaps, 1000);
    </script>
    <script async defer 
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCHQECnK2DXcNXIQR0ZfvIEPrAJWIH8JsM&libraries=places&loading=async&callback=initMap">
    </script>

    <script>
        // Debug log function - defined early
        function debugLog(message, type = 'info') {
            const logDiv = document.getElementById('debugLog');
            if (logDiv) {
                const entry = document.createElement('div');
                entry.className = `debug-entry ${type}`;
                entry.innerHTML = `<strong>${new Date().toLocaleTimeString()}</strong>: ${message}`;
                logDiv.appendChild(entry);
                logDiv.scrollTop = logDiv.scrollHeight;
            }
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        // Global variables
        let map;
        let geocoder;
        let placesService;
        let clickToSaveEnabled = false;
        let currentMarker = null;
        let authToken = null;
        let currentLocationData = null;
        
        // ==========================================
        // LOCATION MARKERS SYSTEM
        // Color-coded markers with filtering
        // ==========================================
        
        // Location type color scheme (matching your existing CSS)
        const LOCATION_TYPE_COLORS = {
            'live reporter': '#ff4444',    // Red
            'live anchor': '#4285f4',      // Blue  
            'live stakeout': '#ffbb33',    // Orange (legacy)
            'stakeout': '#ffbb33',         // Orange
            'live presser': '#00aa00',     // Green (legacy)
            'interview': '#8e44ad',        // Purple
            'broll': '#ad1457',           // Pink
            'default': '#666666'          // Gray fallback
        };
        
        // Type initials for markers
        const TYPE_INITIALS = {
            'live reporter': 'LR',
            'live anchor': 'LA', 
            'live stakeout': 'LS',
            'stakeout': 'ST',
            'live presser': 'LP',
            'interview': 'IN',
            'broll': 'BR'
        };
        
        // NEW: Marker management variables
        let locationMarkers = []; // Store all location markers
        let markerCluster = null; // For marker clustering (future)
        let activeFilters = new Set(['live reporter', 'live anchor', 'stakeout', 'interview', 'broll']); // Default all visible
        let currentInfoWindow = null; // Track open info windows
        
        // Initialize Google Maps - MUST be in global scope for Google Maps API callback
        function initMap() {
            debugLog('Initializing Google Maps...', 'info');
            
            try {
                // Default location (Atlanta, GA)
                const defaultLocation = { lat: 33.7490, lng: -84.3880 };

                // Initialize map
                map = new google.maps.Map(document.getElementById('map'), {
                    zoom: 12,
                    center: defaultLocation,
                    mapTypeControl: true,
                    streetViewControl: true,
                    fullscreenControl: true,
                    zoomControl: true
                });
                
                // Initialize geocoder and places service
                geocoder = new google.maps.Geocoder();
                placesService = new google.maps.places.PlacesService(map);
                
                //dataReadout(placesService);

                // Add click listener
                map.addListener('click', handleMapClick);
                
                debugLog('Google Maps initialized successfully', 'success');
                
                // Load MarkerClusterer library dynamically after Google Maps is ready
                loadMarkerClustererLibrary().then(() => {
                    // Load initial locations with markers
                    loadSavedLocations();
                    
                    // Initialize filter listeners
                    setTimeout(() => {
                        initializeFilterListeners();
                    }, 100); // Small delay to ensure DOM is ready
                }).catch(error => {
                    debugLog('Error loading MarkerClusterer: ' + error.message, 'error');
                    // Still load locations without clustering
                    loadSavedLocations();
                    setTimeout(() => {
                        initializeFilterListeners();
                    }, 100);
                });
                
            } catch (error) {
                debugLog('Error initializing Google Maps: ' + error.message, 'error');
            }
        }
        
        // Make initMap available globally for Google Maps API callback
        window.initMap = initMap;
        
        // Load MarkerClusterer library dynamically
        function loadMarkerClustererLibrary() {
            return new Promise((resolve, reject) => {
                if (typeof markerClusterer !== 'undefined') {
                    resolve();
                    return;
                }
                
                const script = document.createElement('script');
                script.src = 'https://unpkg.com/@googlemaps/markerclusterer/dist/index.min.js';
                script.onload = () => {
                    debugLog('MarkerClusterer library loaded successfully', 'success');
                    resolve();
                };
                script.onerror = () => {
                    reject(new Error('Failed to load MarkerClusterer library'));
                };
                document.head.appendChild(script);
            });
        }
        
        // ==========================================
        // MARKER CREATION FUNCTIONS
        // ==========================================
        
        // Create SVG marker icon with dynamic color
        function createLocationMarkerIcon(type, size = 32) {
            const color = LOCATION_TYPE_COLORS[type?.toLowerCase()] || LOCATION_TYPE_COLORS.default;
            const initials = TYPE_INITIALS[type?.toLowerCase()] || '?';
            
            const svg = `
                <svg width="${size}" height="${size}" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="16" cy="16" r="12" fill="${color}" stroke="white" stroke-width="3"/>
                    <circle cx="16" cy="16" r="6" fill="white"/>
                    <text x="16" y="20" text-anchor="middle" fill="${color}" font-size="8" font-weight="bold" font-family="Arial">
                        ${initials}
                    </text>
                </svg>
            `;
            
            return {
                url: `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(svg)}`,
                scaledSize: new google.maps.Size(size, size),
                anchor: new google.maps.Point(size/2, size/2)
            };
        }
        
        // Create a location marker
        function createLocationMarker(location) {
            if (!location.lat || !location.lng) {
                debugLog(`Skipping marker for ${location.name || 'unnamed'} - missing coordinates`, 'warning');
                return null;
            }
            
            const marker = new google.maps.Marker({
                position: { lat: parseFloat(location.lat), lng: parseFloat(location.lng) },
                map: null, // Don't add to map directly - clustering will handle this
                title: location.name || 'Unnamed Location',
                icon: createLocationMarkerIcon(location.type),
                locationData: location // Store location data for info windows
            });
            
            // Add click listener for info window
            marker.addListener('click', () => {
                showMarkerInfoWindow(marker, location);
            });
            
            debugLog(`Created marker for ${location.name} (${location.type})`, 'success');
            return marker;
        }
        
        // Clear all markers from map
        function clearMapMarkers() {
            // Clear cluster if it exists
            if (markerCluster) {
                markerCluster.clearMarkers();
                markerCluster = null;
                debugLog('Marker cluster cleared', 'info');
            }
            
            // Clear individual markers
            locationMarkers.forEach(marker => {
                if (marker) {
                    marker.setMap(null);
                }
            });
            locationMarkers = [];
            
            // Close any open info windows
            if (currentInfoWindow) {
                currentInfoWindow.close();
                currentInfoWindow = null;
            }
            
            debugLog('All markers cleared from map', 'info');
        }
        
        // Update markers on map
        function updateMapMarkers(locations) {
            debugLog('Updating map markers...', 'info');
            
            // Clear existing markers
            clearMapMarkers();
            
            if (!locations || locations.length === 0) {
                debugLog('No locations to create markers for', 'info');
                updateFilterStats(0, 0);
                return;
            }
            
            // Create new markers
            let createdCount = 0;
            locations.forEach(location => {
                const marker = createLocationMarker(location);
                if (marker) {
                    locationMarkers.push(marker);
                    createdCount++;
                }
            });
            
            // Initialize marker clustering with custom styles
            initializeMarkerClustering();
            
            // Apply current filters (this will also update the cluster)
            applyMarkerFilters();
            
            debugLog(`Created ${createdCount} markers from ${locations.length} locations with clustering`, 'success');
        }
        
        // ==========================================
        // MARKER CLUSTERING FUNCTIONS
        // ==========================================
        
        // Initialize marker clustering with custom cluster styles
        function initializeMarkerClustering() {
            if (typeof markerClusterer === 'undefined' || !locationMarkers.length) {
                debugLog('MarkerClusterer not available or no markers to cluster - using individual markers', 'warning');
                // Fallback: show markers individually
                locationMarkers.forEach(marker => {
                    if (marker.getVisible()) {
                        marker.setMap(map);
                    }
                });
                return;
            }
            
            try {
                // Custom cluster renderer with location type colors
                const renderer = {
                    render: ({ count, position }, stats, map) => {
                        const color = count > 50 ? '#ad1457' : count > 20 ? '#8e44ad' : count > 10 ? '#ff4444' : '#4285f4';
                        const svg = `
                            <svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="20" cy="20" r="16" fill="${color}" stroke="white" stroke-width="3" opacity="0.9"/>
                                <text x="20" y="26" text-anchor="middle" fill="white" font-size="12" font-weight="bold" font-family="Roboto,Arial">
                                    ${count}
                                </text>
                            </svg>
                        `;
                        
                        return new google.maps.Marker({
                            position,
                            icon: {
                                url: `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(svg)}`,
                                scaledSize: new google.maps.Size(40, 40),
                                anchor: new google.maps.Point(20, 20)
                            },
                            label: '',
                            title: `${count} locations`,
                            zIndex: Number(google.maps.Marker.MAX_ZINDEX) + count
                        });
                    }
                };
                
                // Create the MarkerClusterer
                markerCluster = new markerClusterer.MarkerClusterer({
                    markers: locationMarkers,
                    map: map,
                    renderer: renderer,
                    algorithm: new markerClusterer.SuperClusterAlgorithm({
                        radius: 60,        // Cluster radius in pixels
                        maxZoom: 15,       // Maximum zoom to cluster markers
                        minPoints: 2       // Minimum points to form a cluster
                    })
                });
                
                debugLog(`Marker clustering initialized with ${locationMarkers.length} markers`, 'success');
                
            } catch (error) {
                debugLog('Error initializing marker clustering: ' + error.message, 'error');
                // Fallback: show markers individually
                locationMarkers.forEach(marker => {
                    if (marker.getVisible()) {
                        marker.setMap(map);
                    }
                });
            }
        }
        
        // Update clustering when filters change
        function updateMarkerClustering() {
            const clusteringCheckbox = document.getElementById('clustering-enabled');
            
            if (!clusteringCheckbox?.checked || !markerCluster) {
                // Clustering is disabled - show individual markers
                locationMarkers.forEach(marker => {
                    if (marker.getVisible()) {
                        marker.setMap(map);
                    } else {
                        marker.setMap(null);
                    }
                });
                return;
            }
            
            // Get visible markers based on current filters
            const visibleMarkers = locationMarkers.filter(marker => marker.getVisible());
            
            // Update cluster with visible markers only
            markerCluster.clearMarkers();
            markerCluster.addMarkers(visibleMarkers);
            
            debugLog(`Clustering updated with ${visibleMarkers.length} visible markers`, 'info');
        }
        
        // ==========================================
        // MARKER FILTERING FUNCTIONS
        // ==========================================
        
        // Apply marker filters based on current selections
        function applyMarkerFilters() {
            // Get selected filter values
            const selectedTypes = getSelectedFilterTypes();
            activeFilters = new Set(selectedTypes);
            
            let visibleCount = 0;
            let totalCount = locationMarkers.length;
            
            locationMarkers.forEach(marker => {
                if (!marker || !marker.locationData) return;
                
                const locationType = marker.locationData.type?.toLowerCase();
                const shouldShow = selectedTypes.includes(locationType);
                
                marker.setVisible(shouldShow);
                if (shouldShow) visibleCount++;
            });
            
            // Update clustering with filtered markers
            updateMarkerClustering();
            
            // Update filter statistics
            updateFilterStats(visibleCount, totalCount);
            
            debugLog(`Filter applied: ${visibleCount}/${totalCount} markers visible with clustering updated`, 'info');
        }
        
        // Get currently selected filter types
        function getSelectedFilterTypes() {
            const checkboxes = document.querySelectorAll('.filter-option input[type="checkbox"]');
            const selectedTypes = [];
            
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selectedTypes.push(checkbox.value);
                }
            });
            
            return selectedTypes;
        }
        
        // Update filter statistics display
        function updateFilterStats(visibleCount, totalCount) {
            const statsElement = document.getElementById('filter-stats');
            if (!statsElement) return;
            
            if (visibleCount === totalCount) {
                statsElement.textContent = 'All types visible';
                statsElement.style.color = '#28a745';
            } else if (visibleCount === 0) {
                statsElement.textContent = 'No markers visible';
                statsElement.style.color = '#dc3545';
            } else {
                statsElement.textContent = `${visibleCount} of ${totalCount} markers visible`;
                statsElement.style.color = '#ffc107';
            }
        }
        
        // Initialize filter event listeners
        function initializeFilterListeners() {
            const checkboxes = document.querySelectorAll('.filter-option input[type="checkbox"]');
            
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', () => {
                    applyMarkerFilters();
                    debugLog(`Filter toggled: ${checkbox.value} = ${checkbox.checked}`, 'info');
                });
            });
            
            debugLog('Filter event listeners initialized', 'success');
        }
        
        // Toggle all filters on/off
        window.toggleAllFilters = function() {
            const checkboxes = document.querySelectorAll('.filter-option input[type="checkbox"]');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            
            // If all are checked, uncheck all; otherwise check all
            const newState = !allChecked;
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = newState;
            });
            
            applyMarkerFilters();
            debugLog(`All filters ${newState ? 'enabled' : 'disabled'}`, 'info');
        };
        
        // Toggle marker clustering on/off
        window.toggleClustering = function() {
            const clusteringCheckbox = document.getElementById('clustering-enabled');
            const clusterStats = document.getElementById('cluster-stats');
            
            if (clusteringCheckbox.checked) {
                // Enable clustering
                initializeMarkerClustering();
                clusterStats.textContent = 'Clustering active';
                clusterStats.style.color = '#28a745';
                debugLog('Marker clustering enabled', 'success');
            } else {
                // Disable clustering - show individual markers
                if (markerCluster) {
                    markerCluster.clearMarkers();
                    markerCluster = null;
                }
                
                // Show individual markers directly on map
                locationMarkers.forEach(marker => {
                    if (marker.getVisible()) {
                        marker.setMap(map);
                    }
                });
                
                clusterStats.textContent = 'Individual markers';
                clusterStats.style.color = '#6c757d';
                debugLog('Marker clustering disabled', 'info');
            }
        };
        
        // Show rich info window for marker
        function showMarkerInfoWindow(marker, location) {
            const content = `
                <div class="info-window-content" style="font-family: 'Roboto', Arial, sans-serif; color: #333; min-width: 280px; max-width: 320px;">
                    <div class="place-info" style="padding: 12px;">
                        <h3 style="margin: 0 0 8px 0; font-size: 18px; font-weight: 600; color: #1a73e8; line-height: 1.3;">
                            ${escapeHtml(location.name || 'Unnamed Location')}
                        </h3>
                        <p style="margin: 0 0 12px 0; font-size: 14px; color: #5f6368; line-height: 1.4;">
                            ${escapeHtml(location.formatted_address || location.address || 'No address')}
                        </p>
                        <div style="display: inline-block; padding: 4px 12px; background: ${LOCATION_TYPE_COLORS[location.type?.toLowerCase()] || '#666'}; color: white; border-radius: 16px; font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 12px;">
                            ${location.type || 'Unknown'}
                        </div>
                        ${location.production_notes ? `<p style="margin: 8px 0; font-size: 13px;"><strong>Notes:</strong> ${escapeHtml(location.production_notes)}</p>` : ''}
                        ${location.entry_point ? `<p style="margin: 4px 0; font-size: 13px;"><strong>Entry:</strong> ${escapeHtml(location.entry_point)}</p>` : ''}
                        ${location.parking ? `<p style="margin: 4px 0; font-size: 13px;"><strong>Parking:</strong> ${escapeHtml(location.parking)}</p>` : ''}
                        <div style="display: flex; gap: 8px; margin-top: 12px;">
                            <button onclick="centerMapOnLocation(${location.lat}, ${location.lng})" style="flex: 1; padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; background: #6c757d; color: white; transition: all 0.2s ease;">
                                üìç Center
                            </button>
                            ${location.place_id ? `<button onclick="editLocation('${location.place_id}')" style="flex: 1; padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; background: #1a73e8; color: white; transition: all 0.2s ease;">
                                ‚úèÔ∏è Edit
                            </button>` : ''}
                        </div>
                    </div>
                </div>
            `;
            
            // Close any existing info window
            if (currentInfoWindow) {
                currentInfoWindow.close();
            }
            
            currentInfoWindow = new google.maps.InfoWindow({
                content: content,
                maxWidth: 320
            });
            
            currentInfoWindow.open(map, marker);
            debugLog(`Opened info window for ${location.name}`, 'info');
        }
        
        // Center map on location
        function centerMapOnLocation(lat, lng) {
            map.setCenter({ lat: parseFloat(lat), lng: parseFloat(lng) });
            map.setZoom(16);
            debugLog(`Centered map on location: ${lat}, ${lng}`, 'info');
        }
        
        // Handle map clicks
        function handleMapClick(event) {
            if (!clickToSaveEnabled) {
                debugLog('Click to save is disabled', 'info');
                return;
            }
            
            if (!authToken) {
                debugLog('Authentication required to save locations', 'error');
                alert('Please login first to save locations');
                return;
            }
            


            debugLog('Map clicked at: ' + event.latLng.lat() + ', ' + event.latLng.lng(), 'info');
            
            // Remove existing marker
            if (currentMarker) {
                currentMarker.setMap(null);
            }
            
            // Add new marker
            currentMarker = new google.maps.Marker({
                position: event.latLng,
                map: map,
                title: 'Click to save this location',
                icon: {
                    url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                        <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="16" cy="16" r="12" fill="#4285f4" stroke="white" stroke-width="3"/>
                            <circle cx="16" cy="16" r="6" fill="white"/>
                        </svg>
                    `),
                    scaledSize: new google.maps.Size(32, 32),
                    anchor: new google.maps.Point(16, 16)
                }
            });
            

            // Get location details
            getLocationDetails(event.latLng);
        }
        
        // Get location details from Google Maps
        async function getLocationDetails(latLng) {
            debugLog('Getting location details...', 'info');
            
            try {
                const results = await geocodeLocation(latLng);
                
                if (results && results.length > 0) {
                    const result = results[0];
                    const locationData = parseLocationData(result, latLng);

                    // Log the location data
                    dataReadout(locationData);

                    debugLog('Location data parsed: ' + locationData.address, 'success');
                    
                    // Show save dialog
                    showSaveLocationDialog(locationData);
                } else {
                    debugLog('No geocoding results found', 'error');
                    // Show dialog with basic coordinates
                    showSaveLocationDialog({
                        lat: latLng.lat(),
                        lng: latLng.lng(),
                        address: `${latLng.lat().toFixed(6)}, ${latLng.lng().toFixed(6)}`,
                        name: 'Unknown Location'
                    });
                }
            } catch (error) {
                debugLog('Error getting location details: ' + error.message, 'error');
                // Show dialog with basic coordinates
                showSaveLocationDialog({
                    lat: latLng.lat(),
                    lng: latLng.lng(),
                    address: `${latLng.lat().toFixed(6)}, ${latLng.lng().toFixed(6)}`,
                    name: 'Unknown Location'
                });
            }
        }
        
        // Geocode location
        function geocodeLocation(latLng) {
            return new Promise((resolve, reject) => {
                geocoder.geocode({ location: latLng }, (results, status) => {
                    if (status === 'OK') {
                        dataReadout(results, "Geocoding Results", 5);
                        resolve(results);
                    } else {
                        reject(new Error('Geocoding failed: ' + status));
                    }
                });
            });
        }
        
        // Parse location data from geocoding result
        function parseLocationData(result, latLng) {
            const components = result.address_components;
            const locationData = {
                lat: latLng.lat(),
                lng: latLng.lng(),
                address: result.formatted_address,
                place_id: result.place_id,
                name: result.formatted_address,
                street: '',
                number: '',
                city: '',
                state: '',
                zipcode: ''
            };
            
            // Parse address components
            components.forEach(component => {
                const types = component.types;
                
                if (types.includes('street_number')) {
                    locationData.number = component.long_name;
                } else if (types.includes('route')) {
                    locationData.street = component.long_name;
                } else if (types.includes('locality')) {
                    locationData.city = component.long_name;
                } else if (types.includes('administrative_area_level_1')) {
                    locationData.state = component.short_name;
                } else if (types.includes('postal_code')) {
                    locationData.zipcode = component.long_name;
                }
            });
            

           // dataReadout(locationData);

            return locationData;
        }
        
        // Show save location dialog
        function showSaveLocationDialog(locationData) {
            debugLog('Showing save location dialog', 'info');
            
            currentLocationData = locationData;
            
            // Populate form with Google data
            document.getElementById('locationAddress').textContent = locationData.address || 'No address available';
            
            // Default name to "street + city" format
            const defaultName = locationData.street && locationData.city 
                ? `${locationData.street} ${locationData.city}` 
                : locationData.name || 'Unknown Location';
            
            document.getElementById('locationName').value = defaultName;
            document.getElementById('locationStreet').value = locationData.street || '';
            document.getElementById('locationNumber').value = locationData.number || '';
            document.getElementById('locationCity').value = locationData.city || '';
            document.getElementById('locationState').value = locationData.state || '';
            document.getElementById('locationZipcode').value = locationData.zipcode || '';
            document.getElementById('locationLat').value = locationData.lat || '';
            document.getElementById('locationLng').value = locationData.lng || '';
            document.getElementById('locationPlaceId').value = locationData.place_id || '';
            document.getElementById('formattedAddress').value = locationData.address || '';
            
            // Clear production notes and set up character counter
            const notesField = document.getElementById('productionNotes');
            notesField.value = '';
            updateCharacterCount();
            
            // Show modal
            document.getElementById('saveLocationModal').style.display = 'block';
        }
        
        // Update character count for production notes
        function updateCharacterCount() {
            const notesField = document.getElementById('productionNotes');
            const charCount = document.querySelector('.char-count');
            const currentLength = notesField.value.length;
            const maxLength = 200;
            
            charCount.textContent = `${currentLength}/${maxLength} characters`;
            
            if (currentLength > maxLength * 0.9) {
                charCount.className = 'char-count error';
            } else if (currentLength > maxLength * 0.75) {
                charCount.className = 'char-count warning';
            } else {
                charCount.className = 'char-count';
            }
        }
        
        // Add event listener for character counter when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            const notesField = document.getElementById('productionNotes');
            if (notesField) {
                notesField.addEventListener('input', updateCharacterCount);
            }
            
            // Initialize filters if they exist and haven't been initialized yet
            setTimeout(() => {
                if (typeof initializeFilterListeners === 'function') {
                    try {
                        initializeFilterListeners();
                        debugLog('Filter listeners initialized from DOMContentLoaded', 'success');
                    } catch (error) {
                        debugLog('Error initializing filter listeners: ' + error.message, 'warning');
                    }
                }
            }, 200); // Delay to ensure all DOM elements are ready
        });
        
        // Close save modal
        window.closeSaveModal = function() {
            document.getElementById('saveLocationModal').style.display = 'none';
            
            // Remove marker
            if (currentMarker) {
                currentMarker.setMap(null);
                currentMarker = null;
            }

            // Clear photo selection
            removePhoto();
            
            // Clear pending photos
            window.pendingPhotos = [];
        };

        // Photo handling functions
        let selectedPhotoFile = null;

        window.handleDragOver = function(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        };

        window.handleDragLeave = function(event) {
            event.currentTarget.classList.remove('dragover');
        };

        window.allowDrop = function(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        };

        window.handlePhotoDrop = function(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                handlePhotoFile(files[0]);
            }
        };

        window.handlePhotoSelect = function(event) {
            const file = event.target.files[0];
            if (file) {
                handlePhotoFile(file);
            }
        };

        function showPhotoPreview(src) {
            const placeholder = document.getElementById('uploadPlaceholder');
            const preview = document.getElementById('photoPreview');
            const previewImage = document.getElementById('previewImage');
            
            placeholder.style.display = 'none';
            preview.style.display = 'block';
            previewImage.src = src;
        }

        window.removePhoto = function() {
            selectedPhotoFile = null;
            
            const placeholder = document.getElementById('uploadPlaceholder');
            const preview = document.getElementById('photoPreview');
            const previewImage = document.getElementById('previewImage');
            const fileInput = document.getElementById('locationPhoto');
            
            if (placeholder) placeholder.style.display = 'flex';
            if (preview) preview.style.display = 'none';
            if (previewImage) previewImage.src = '';
            if (fileInput) fileInput.value = '';
            
            // Remove the updatePhotoStatus call since the element doesn't exist
            debugLog('Photo removed', 'info');
        };

        function updatePhotoStatus(message, type = '') {
            // Try to find the photo status element in the current context
            let statusElement = document.getElementById('photoStatus');
            
            // If not found, try to find it in any visible modal
            if (!statusElement) {
                const visibleModal = document.querySelector('.modal[style*="block"]');
                if (visibleModal) {
                    statusElement = visibleModal.querySelector('#photoStatus, .photo-status');
                }
            }
            
            // Update element if found
            if (statusElement) {
                try {
                    statusElement.textContent = message;
                    statusElement.className = `photo-status ${type}`;
                } catch (err) {
                    // Silently handle any DOM manipulation errors
                    console.warn('Photo status element update failed:', err);
                }
            }
            
            // Always log the photo status for debugging (this is the main feedback now)
            if (message) {
                debugLog(`Photo Status: ${message}`, type === 'error' ? 'error' : 'info');
            }
        }

        // Upload photo to server
        async function uploadPhoto(placeId, file) {
            if (!authToken) {
                throw new Error('Please login before uploading photos');
            }
            
            const formData = new FormData();
            formData.append('photo', file);
            formData.append('placeId', placeId);
            
            // Get caption if provided (we can add this field later)
            // const caption = document.getElementById('photoCaption')?.value.trim();
            // if (caption) formData.append('caption', caption);
            
            const response = await fetch('/api/photos/upload', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${authToken}`
                },
                body: formData
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.message || 'Photo upload failed');
            }
            
            return response.json();
        }

        // Load photos for a location
        async function loadLocationPhotos(placeId) {
            try {
                const response = await fetch(`/api/photos/location/${encodeURIComponent(placeId)}`);
                if (!response.ok) {
                    throw new Error('Failed to load photos');
                }
                const data = await response.json();
                return data.success ? data.data : [];
            } catch (error) {
                debugLog(`Error loading photos: ${error.message}`, 'error');
                return [];
            }
        }

        // Display photos in location card
        function displayLocationPhotos(photos, container, placeId, showAddButton = false) {
            container.innerHTML = '';

            if (photos.length === 0 && !showAddButton) {
                container.innerHTML = '<div class="no-photos-message">No photos yet</div>';
                return;
            }

            const photosGrid = document.createElement('div');
            photosGrid.className = 'photos-grid';

            // Display existing photos
            photos.forEach(photo => {
                const thumbnail = document.createElement('div');
                thumbnail.className = `photo-thumbnail ${photo.is_primary ? 'primary' : ''}`;
                thumbnail.onclick = () => openPhotoModal(photo);

                thumbnail.innerHTML = `
                    <img src="${photo.urls.thumbnail}" alt="${photo.caption || 'Location photo'}" loading="lazy">
                    ${photo.is_primary ? '<div class="photo-primary-badge">‚òÖ</div>' : ''}
                `;

                photosGrid.appendChild(thumbnail);
            });

            // Add "Add Photo" button if in edit mode
            if (showAddButton) {
                const addButton = document.createElement('div');
                addButton.className = 'add-photo-btn';
                addButton.onclick = () => {
                    // Find the edit modal and trigger photo upload toggle
                    const editModal = document.getElementById('editLocationModal');
                    if (editModal) {
                        togglePhotoUpload('edit');
                    }
                };
                addButton.innerHTML = '<div class="plus-icon">+</div><div>Add Photo</div>';
                photosGrid.appendChild(addButton);
            }

            container.appendChild(photosGrid);
        }

        // Open photo in modal
        function openPhotoModal(photo) {
            const modal = document.getElementById('photoModal');
            const image = document.getElementById('photoModalImage');
            const caption = document.getElementById('photoModalCaption');
            const meta = document.getElementById('photoModalMeta');

            image.src = photo.urls.large;
            caption.textContent = photo.caption || 'No caption';
            meta.textContent = `Uploaded by ${photo.uploaded_by_username || 'Unknown'} ‚Ä¢ ${new Date(photo.uploaded_at).toLocaleDateString()}`;

            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        // Close photo modal
        window.closePhotoModal = function() {
            const modal = document.getElementById('photoModal');
            modal.classList.remove('show');
            document.body.style.overflow = 'auto';
        };

        // Toggle photo upload interface
        window.togglePhotoUpload = function(mode) {
            const uploadSection = document.getElementById(`${mode}-photo-upload`);
            
            // Get the correct form and button based on mode
            let toggleBtn;
            if (mode === 'edit') {
                toggleBtn = document.querySelector('#editLocationModal .photo-toggle-btn');
            } else {
                toggleBtn = document.querySelector('#saveLocationForm .photo-toggle-btn');
            }
            
            if (!toggleBtn) {
                console.error('Toggle button not found for mode:', mode);
                return;
            }
            
            const toggleText = toggleBtn.querySelector('.toggle-text');
            
            if (uploadSection.style.display === 'none' || uploadSection.style.display === '') {
                uploadSection.style.display = 'block';
                toggleText.textContent = 'Hide Upload';
                toggleBtn.classList.add('active');
            } else {
                uploadSection.style.display = 'none';
                toggleText.textContent = 'Add Photos';
                toggleBtn.classList.remove('active');
            }
        };

        // Enhanced photo drop handler with mode support
        window.handlePhotoDrop = function(event, mode = 'save') {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
            
            const files = Array.from(event.dataTransfer.files);
            files.forEach(file => {
                if (file.type.startsWith('image/')) {
                    handlePhotoFile({ target: { files: [file] } }, mode);
                }
            });
        };

        // Enhanced photo file handler with mode support
        window.handlePhotoFile = function(eventOrFile, mode = 'save') {
            let files = [];
            
            // Handle both old style (direct file) and new style (event object)
            if (eventOrFile && eventOrFile.target && eventOrFile.target.files) {
                // New style: event object
                files = Array.from(eventOrFile.target.files);
            } else if (eventOrFile && eventOrFile.type && eventOrFile.type.startsWith('image/')) {
                // Old style: direct file object
                files = [eventOrFile];
                // For old style calls, use the old function
                return handlePhotoFileOld(eventOrFile);
            } else {
                debugLog('Invalid file or event object', 'error');
                return;
            }
            
            files.forEach(file => {
                // Validate file type
                if (!file.type.startsWith('image/')) {
                    debugLog('Please select an image file', 'error');
                    return;
                }

                // Validate file size (10MB)
                if (file.size > 10 * 1024 * 1024) {
                    debugLog('File size must be less than 10MB', 'error');
                    return;
                }

                // Create preview
                const reader = new FileReader();
                reader.onload = function(e) {
                    addPhotoPreview(e.target.result, file, mode);
                };
                reader.readAsDataURL(file);
            });
        };

        // Keep the old function for backward compatibility
        function handlePhotoFileOld(file) {
            // Validate file type
            if (!file.type.startsWith('image/')) {
                debugLog('Please select an image file', 'error');
                return;
            }

            // Validate file size (10MB)
            if (file.size > 10 * 1024 * 1024) {
                debugLog('File size must be less than 10MB', 'error');
                return;
            }

            selectedPhotoFile = file;
            
            // Show preview
            const reader = new FileReader();
            reader.onload = function(e) {
                showPhotoPreview(e.target.result);
                debugLog(`Selected: ${file.name} (${(file.size / 1024 / 1024).toFixed(1)}MB)`, 'success');
            };
            reader.readAsDataURL(file);
        }

        // Add photo preview to the preview area
        function addPhotoPreview(src, file, mode) {
            const previewContainer = document.getElementById(`${mode}-photo-preview`);
            
            const previewItem = document.createElement('div');
            previewItem.className = 'photo-preview-item';
            previewItem.innerHTML = `
                <div class="preview-image-container">
                    <img src="${src}" alt="Preview">
                    <button type="button" class="remove-preview-btn" onclick="removePhotoPreview(this, '${mode}')">√ó</button>
                </div>
                <div class="preview-info">
                    <div class="file-name">${file.name}</div>
                    <div class="file-size">${(file.size / 1024 / 1024).toFixed(1)}MB</div>
                </div>
                <button type="button" class="upload-btn" onclick="uploadPhotoFromPreview(this, '${mode}')">Upload</button>
            `;
            
            // Store file data
            previewItem._fileData = file;
            previewContainer.appendChild(previewItem);
        }

        // Remove photo preview
        window.removePhotoPreview = function(button, mode) {
            const previewItem = button.closest('.photo-preview-item');
            previewItem.remove();
        };

        // Upload photo from preview
        window.uploadPhotoFromPreview = async function(button, mode) {
            const previewItem = button.closest('.photo-preview-item');
            const file = previewItem._fileData;
            
            if (mode === 'edit') {
                // Use save-style workflow for edit mode too - store for later upload
                if (!window.pendingEditPhotos) window.pendingEditPhotos = [];
                window.pendingEditPhotos.push(file);
                
                previewItem.innerHTML = `
                    <div class="preview-image-container">
                        <img src="${previewItem.querySelector('img').src}" alt="Preview">
                        <div class="upload-status">Ready to upload when saved</div>
                    </div>
                    <div class="preview-info">
                        <div class="file-name">${file.name}</div>
                        <div class="file-size">${(file.size / 1024 / 1024).toFixed(1)}MB</div>
                    </div>
                `;
                
                debugLog('Photo queued for upload when location is saved', 'info');
            } else {
                // Save mode - store for later upload when location is saved
                if (!window.pendingPhotos) window.pendingPhotos = [];
                window.pendingPhotos.push(file);
                
                previewItem.innerHTML = `
                    <div class="preview-image-container">
                        <img src="${previewItem.querySelector('img').src}" alt="Preview">
                        <div class="upload-status">Ready to upload</div>
                    </div>
                    <div class="preview-info">
                        <div class="file-name">${file.name}</div>
                        <div class="file-size">${(file.size / 1024 / 1024).toFixed(1)}MB</div>
                    </div>
                `;
            }
        };

        // Load photos for edit form
        async function loadEditFormPhotos(placeId) {
            try {
                const photos = await loadLocationPhotos(placeId);
                const container = document.getElementById('edit-photos-grid');
                displayLocationPhotos(photos, container, placeId, true);
            } catch (error) {
                debugLog(`Error loading edit form photos: ${error.message}`, 'error');
            }
        }

        // Handle form submission
        document.getElementById('saveLocationForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            debugLog('Saving location...', 'info');
            
            if (!authToken) {
                debugLog('Authentication required', 'error');
                alert('Please login first');
                return;
            }
            
            try {
                // Collect form data according to new database structure
                const formData = {
                    name: document.getElementById('locationName').value.trim(),
                    lat: parseFloat(document.getElementById('locationLat').value),
                    lng: parseFloat(document.getElementById('locationLng').value),
                    formatted_address: document.getElementById('formattedAddress').value,
                    production_notes: document.getElementById('productionNotes').value.trim(),
                    type: document.getElementById('locationType').value,
                    entry_point: document.getElementById('entryPoint').value || null,
                    parking: document.getElementById('parking').value || null,
                    access: document.getElementById('access').value || null,
                    street: document.getElementById('locationStreet').value.trim(),
                    number: document.getElementById('locationNumber').value.trim(),
                    city: document.getElementById('locationCity').value.trim(),
                    state: document.getElementById('locationState').value.trim(),
                    zipcode: document.getElementById('locationZipcode').value.trim(),
                    place_id: document.getElementById('locationPlaceId').value
                };
                
                // Validate required fields
                if (!formData.name) {
                    alert('Location name is required');
                    return;
                }
                
                if (!formData.type) {
                    alert('Location type is required');
                    return;
                }
                
                // Validate state length
                if (formData.state && formData.state.length > 2) {
                    alert('State must be 2 characters or less');
                    return;
                }
                
                // Validate zipcode length
                if (formData.zipcode && formData.zipcode.length > 5) {
                    alert('Zipcode must be 5 characters or less');
                    return;
                }
                
                // Validate production notes length
                if (formData.production_notes && formData.production_notes.length > 200) {
                    alert('Production notes must be 200 characters or less');
                    return;
                }
                
                debugLog('Form data collected: ' + JSON.stringify(formData), 'info');
                
                // Save to API
                const response = await fetch('http://localhost:3000/api/locations/save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(formData)
                });
                
                if (response.ok) {
                    const savedLocation = await response.json();
                    debugLog('API Response: ' + JSON.stringify(savedLocation), 'info');
                    debugLog('Location saved successfully: ' + (savedLocation.name || savedLocation.data?.name || 'Location'), 'success');
                    
                    // Get the actual place_id from response
                    const actualPlaceId = savedLocation.place_id || savedLocation.data?.place_id || formData.place_id;
                    
                    // Upload pending photos if any
                    if (window.pendingPhotos && window.pendingPhotos.length > 0 && actualPlaceId) {
                        try {
                            debugLog('Uploading pending photos...', 'info');
                            for (const photo of window.pendingPhotos) {
                                await uploadPhoto(actualPlaceId, photo);
                            }
                            debugLog(`${window.pendingPhotos.length} photos uploaded successfully`, 'success');
                            window.pendingPhotos = []; // Clear pending photos
                        } catch (photoError) {
                            debugLog('Photo upload failed: ' + photoError.message, 'error');
                            // Don't fail the entire save for photo upload issues
                        }
                    }
                    
                    // Upload old-style photo if one was selected (backward compatibility)
                    if (selectedPhotoFile && actualPlaceId) {
                        try {
                            debugLog('Uploading legacy photo...', 'info');
                            await uploadPhoto(actualPlaceId, selectedPhotoFile);
                            debugLog('Legacy photo uploaded successfully', 'success');
                        } catch (photoError) {
                            debugLog('Legacy photo upload failed: ' + photoError.message, 'error');
                            // Don't fail the entire save for photo upload issues
                        }
                    }
                    
                    // Close modal
                    closeSaveModal();
                    
                    // Refresh locations list and markers
                    await loadSavedLocations();
                    
                    // Show success message
                    const photoCount = (window.pendingPhotos?.length || 0) + (selectedPhotoFile ? 1 : 0);
                    const message = photoCount > 0 ? `Location and ${photoCount} photo(s) saved successfully!` : 'Location saved successfully!';
                    alert(message);
                } else {
                    const error = await response.json();
                    debugLog('Error saving location: ' + error.error, 'error');
                    alert('Error saving location: ' + error.error);
                }
            } catch (error) {
                debugLog('Error saving location: ' + error.message, 'error');
                alert('Error saving location: ' + error.message);
            }
        });
        
        // Toggle click to save
        window.toggleClickToSave = function() {
            if (!map) {
                debugLog('Map not initialized yet', 'error');
                alert('Please wait for Google Maps to load first');
                return;
            }
            
            clickToSaveEnabled = !clickToSaveEnabled;
            
            const btn = document.getElementById('clickToSaveBtn');
            const status = document.getElementById('mapStatus');
            
            if (clickToSaveEnabled) {
                btn.textContent = 'Disable Click to Save';
                btn.classList.add('active');
                status.textContent = 'Click to Save: Enabled';
                status.classList.add('active');
                map.setOptions({ cursor: 'crosshair' });
                debugLog('Click to save enabled', 'success');
            } else {
                btn.textContent = 'Enable Click to Save';
                btn.classList.remove('active');
                status.textContent = 'Click to Save: Disabled';
                status.classList.remove('active');
                map.setOptions({ cursor: 'default' });
                debugLog('Click to save disabled', 'info');
                
                // Remove any existing marker
                if (currentMarker) {
                    currentMarker.setMap(null);
                    currentMarker = null;
                }
            }
        };
        
        // Login function
        window.login = async function() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            
            debugLog('Attempting login...', 'info');

            
            
            try {
                const response = await fetch('http://localhost:3000/api/auth/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email, password })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    authToken = data.token;
                    
                    const statusDiv = document.getElementById('authStatus');
                    statusDiv.className = 'auth-status success';
                    statusDiv.style.display = 'block';
                    statusDiv.innerHTML = `‚úÖ Logged in as ${data.user.username}`;
                    
                    debugLog('Login successful for user: ' + data.user.username, 'success');
                    
                    // Load saved locations
                    await loadSavedLocations();
                } else {
                    const error = await response.json();
                    
                    const statusDiv = document.getElementById('authStatus');
                    statusDiv.className = 'auth-status error';
                    statusDiv.style.display = 'block';
                    statusDiv.innerHTML = `‚ùå Login failed: ${error.error}`;
                    
                    debugLog('Login failed: ' + error.error, 'error');
                }
            } catch (error) {
                debugLog('Login error: ' + error.message, 'error');
                
                const statusDiv = document.getElementById('authStatus');
                statusDiv.className = 'auth-status error';
                statusDiv.style.display = 'block';
                statusDiv.innerHTML = `‚ùå Login error: ${error.message}`;
            }
        };
        
        // Load saved locations
        async function loadSavedLocations() {
            debugLog('Loading saved locations...', 'info');
            
            try {
                const response = await fetch('http://localhost:3000/api/locations/with-creators');
                const data = await response.json();
                
                if (data.success) {
                    const locations = data.data;
                    debugLog(`Loaded ${locations.length} locations`, 'success');
                    
                    // Use the reusable data readout function
                    dataReadout(data, 'Locations API Response');

                    // Render sidebar list
                    renderLocationsList(locations);
                    
                    // Create/update map markers
                    updateMapMarkers(locations);
                } else {
                    debugLog('Failed to load locations', 'error');
                    dataReadout(data, 'Failed API Response');
                }
            } catch (error) {
                debugLog('Error loading locations: ' + error.message, 'error');
            }
        }
        
        // Render locations list
        async function renderLocationsList(locations) {
            const container = document.getElementById('savedLocationsList');
            
            if (!locations || locations.length === 0) {
                container.innerHTML = `
                    <div class="no-locations">
                        <p>No saved locations yet</p>
                        <p>Click on the map to save a location</p>
                    </div>
                `;
                return;
            }
            
            // Load photos for all locations
            const locationsWithPhotos = await Promise.all(
                locations.map(async (location) => {
                    const photos = await loadLocationPhotos(location.place_id);
                    return { ...location, photos };
                })
            );
            
            const html = locationsWithPhotos.map(location => `
                <div class="location-item" data-place-id="${location.place_id}">
                    <h4>${escapeHtml(location.name || 'Unnamed Location')}</h4>
                    <p><strong>Address:</strong> ${escapeHtml(location.formatted_address || location.address || 'No address')}</p>
                    <p><strong>Type:</strong> ${escapeHtml(location.type || 'Unknown')}</p>
                    ${location.production_notes ? `<p><strong>Production Notes:</strong> ${escapeHtml(location.production_notes)}</p>` : ''}
                    ${location.entry_point ? `<p><strong>Entry Point:</strong> ${escapeHtml(location.entry_point)}</p>` : ''}
                    ${location.parking ? `<p><strong>Parking:</strong> ${escapeHtml(location.parking)}</p>` : ''}
                    ${location.access ? `<p><strong>Access:</strong> ${escapeHtml(location.access)}</p>` : ''}
                    <p><strong>Location:</strong> ${location.number || ''} ${location.street || ''}, ${location.city || ''}, ${location.state || ''}, ${location.zipcode || ''}</p>
                    <p><strong>Coordinates:</strong> ${location.lat}, ${location.lng}</p>
                    <p><strong>Created by:</strong> ${escapeHtml(location.creator_username || 'Unknown')}</p>
                    <p><strong>Created:</strong> ${new Date(location.created_date || location.created_at).toLocaleDateString()}</p>
                    ${location.updated_date ? `<p><strong>Updated:</strong> ${new Date(location.updated_date).toLocaleDateString()}</p>` : ''}
                    
                    <!-- Photos Section -->
                    <div class="photos-section">
                        <div class="photos-header">
                            <span class="photos-title">üì∏ Photos</span>
                            <span class="photo-count">${location.photos.length}</span>
                        </div>
                        <div class="photos-container" id="photos-${location.place_id}"></div>
                    </div>
                    
                    <div class="location-actions">
                        <button onclick="viewOnMap(${location.lat}, ${location.lng})">üìç View on Map</button>
                        <button onclick="editLocation('${location.place_id}')">‚úèÔ∏è Edit</button>
                        <button onclick="deleteLocation('${location.place_id}')">üóëÔ∏è Delete</button>
                    </div>
                </div>
            `).join('');
            
            container.innerHTML = html;

            // Display photos for each location
            locationsWithPhotos.forEach(location => {
                const photosContainer = document.getElementById(`photos-${location.place_id}`);
                if (photosContainer) {
                    displayLocationPhotos(location.photos, photosContainer, location.place_id, false);
                }
            });
        }
        
        // View location on map
        window.viewOnMap = function(lat, lng) {
            if (!map) {
                debugLog('Map not initialized yet', 'error');
                alert('Please wait for Google Maps to load first');
                return;
            }
            
            // Center map on location
            centerMapOnLocation(lat, lng);
            
            // Find and highlight the corresponding marker
            const marker = locationMarkers.find(m => 
                m && Math.abs(m.getPosition().lat() - lat) < 0.0001 && 
                Math.abs(m.getPosition().lng() - lng) < 0.0001
            );
            
            if (marker) {
                // Bounce animation
                marker.setAnimation(google.maps.Animation.BOUNCE);
                setTimeout(() => marker.setAnimation(null), 2000);
                
                // Show info window
                showMarkerInfoWindow(marker, marker.locationData);
                
                debugLog(`Highlighted marker for location at ${lat}, ${lng}`, 'success');
            } else {
                debugLog(`No marker found for location at ${lat}, ${lng}`, 'warning');
            }
        };
        
        // Edit location
        window.editLocation = async function(placeId) {
            debugLog('Edit location requested for place_id: ' + placeId, 'info');
            
            try {
                // Fetch the existing location data
                const response = await fetch(`http://localhost:3000/api/locations/${placeId}`, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch location data');
                }
                
                const apiResponse = await response.json();
                debugLog('Raw API response: ' + JSON.stringify(apiResponse), 'info');
                
                // Check if response is wrapped (has success/data structure)
                let location;
                if (apiResponse.success && apiResponse.data) {
                    location = apiResponse.data;
                    debugLog('Using wrapped response - location extracted from data property', 'info');
                } else if (apiResponse.place_id || apiResponse.id) {
                    location = apiResponse;
                    debugLog('Using direct response - location is the response itself', 'info');
                } else {
                    debugLog('Response structure: ' + Object.keys(apiResponse).join(', '), 'info');
                    location = apiResponse;
                }
                
                debugLog('Final location object for editing: ' + JSON.stringify(location), 'info');
                
                // Show the edit modal with the location data
                showEditLocationModal(location);

                dataReadout(location, 'window.editLocation');

                
            } catch (error) {
                debugLog('Error fetching location for edit: ' + error.message, 'error');
                alert('Failed to load location data for editing');
            }
        };
        
        // Show edit location modal
        function showEditLocationModal(location) {
            // Always remove existing modal to ensure fresh state
            let existingModal = document.getElementById('editLocationModal');
            if (existingModal) {
                existingModal.remove();
                debugLog('Removed existing edit modal for fresh state', 'info');
            }
            
            // Create new edit modal
            const editModal = document.createElement('div');
            editModal.id = 'editLocationModal';
            editModal.className = 'modal';
            document.body.appendChild(editModal);
            
            // Generate the comprehensive form HTML with current location data
            const formHTML = generateLocationFormHTML(location);
            
            editModal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Edit Location</h2>
                        <span class="close" onclick="closeEditModal()">&times;</span>
                    </div>
                    <form id="editLocationForm" onsubmit="handleEditLocationSubmit(event)">
                        <input type="hidden" id="edit_place_id" value="${location.place_id || location.id || ''}">
                        ${formHTML}
                        <div class="form-actions">
                            <button type="button" class="btn-secondary" onclick="closeEditModal()">Cancel</button>
                            <button type="submit" class="btn-primary">Update Location</button>
                        </div>
                    </form>
                </div>
            `;
            
            editModal.style.display = 'block';
            debugLog('Edit modal opened for location: ' + (location.name || location.place_id), 'info');
            
            // Setup form enhancements for the edit form
            setupEditFormEnhancements();
        }
        
        // Close edit modal
        function closeEditModal() {
            const editModal = document.getElementById('editLocationModal');
            if (editModal) {
                editModal.style.display = 'none';
                
                // Reset form to prevent data persistence
                const form = document.getElementById('editLocationForm');
                if (form) {
                    form.reset();
                }
                
                // Clear pending edit photos
                window.pendingEditPhotos = [];
                
                debugLog('Edit modal closed and form reset', 'info');
            }
        }
        
        // Setup form enhancements for edit form
        function setupEditFormEnhancements() {
            // Character counting for production notes (matching the save form structure)
            const productionNotesField = document.getElementById('edit_productionNotes');
            const charCount = document.querySelector('#editLocationModal .char-count');
            
            if (productionNotesField && charCount) {
                function updateEditCharCount() {
                    const currentLength = productionNotesField.value.length;
                    const maxLength = 200;
                    
                    charCount.textContent = `${currentLength}/${maxLength} characters`;
                    
                    if (currentLength > maxLength * 0.9) {
                        charCount.className = 'char-count error';
                    } else if (currentLength > maxLength * 0.75) {
                        charCount.className = 'char-count warning';
                    } else {
                        charCount.className = 'char-count';
                    }
                }
                
                productionNotesField.addEventListener('input', updateEditCharCount);
                updateEditCharCount(); // Initial update
            }
            
            // Setup live address updating
            setupLiveAddressUpdate();
            
            // Load existing photos for the edit form
            const placeId = document.getElementById('edit_locationPlaceId').value;
            if (placeId) {
                loadEditFormPhotos(placeId);
            }
        }
        
        // Live address formatting function
        function formatLiveAddress(components) {
            const { number, street, city, state, zipcode } = components;
            
            // Build address parts
            const parts = [];
            
            // Street address (number + street)
            if (number || street) {
                const streetPart = [number, street].filter(Boolean).join(' ');
                if (streetPart.trim()) {
                    parts.push(streetPart.trim());
                }
            }
            
            // City
            if (city && city.trim()) {
                parts.push(city.trim());
            }
            
            // State and zipcode (together)
            if (state || zipcode) {
                const stateZip = [state, zipcode].filter(Boolean).join(' ');
                if (stateZip.trim()) {
                    parts.push(stateZip.trim());
                }
            }
            
            // Join with commas
            let formattedAddress = '';
            if (parts.length > 0) {
                if (parts.length === 1) {
                    formattedAddress = parts[0];
                } else if (parts.length === 2) {
                    formattedAddress = parts.join(', ');
                } else {
                    formattedAddress = parts.slice(0, -1).join(', ') + ', ' + parts[parts.length - 1];
                }
            }
            
            // Add USA if we have a complete address
            if (formattedAddress && (state || zipcode)) {
                formattedAddress += ', USA';
            }
            
            return formattedAddress;
        }
        
        // Update the live address display in edit form
        function updateEditLiveAddress() {
            const components = {
                number: document.getElementById('edit_locationNumber')?.value.trim() || '',
                street: document.getElementById('edit_locationStreet')?.value.trim() || '',
                city: document.getElementById('edit_locationCity')?.value.trim() || '',
                state: document.getElementById('edit_locationState')?.value.trim() || '',
                zipcode: document.getElementById('edit_locationZipcode')?.value.trim() || ''
            };
            
            const formattedAddress = formatLiveAddress(components);
            const displayElement = document.getElementById('editLocationAddress');
            const hiddenField = document.getElementById('edit_formattedAddress');
            
            if (displayElement) {
                // Update display with animation
                if (formattedAddress) {
                    displayElement.textContent = formattedAddress;
                    displayElement.style.borderColor = '#28a745';
                    displayElement.style.background = '#d4edda';
                    
                    // Reset styles after animation
                    setTimeout(() => {
                        displayElement.style.borderColor = '#dee2e6';
                        displayElement.style.background = '#f8f9fa';
                    }, 500);
                } else {
                    displayElement.textContent = 'Address will appear here...';
                    displayElement.style.borderColor = '#dee2e6';
                    displayElement.style.background = '#f8f9fa';
                }
            }
            
            // Update hidden field for form submission
            if (hiddenField) {
                hiddenField.value = formattedAddress;
            }
            
            debugLog(`Edit form address updated: "${formattedAddress}"`, 'info');
        }
        
        // Setup live address updating for edit form
        function setupLiveAddressUpdate() {
            const addressFields = ['edit_locationNumber', 'edit_locationStreet', 'edit_locationCity', 'edit_locationState', 'edit_locationZipcode'];
            
            addressFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.addEventListener('input', function() {
                        // Validate state and zipcode length
                        if (fieldId === 'edit_locationState' && this.value.length > 2) {
                            this.value = this.value.substring(0, 2);
                            debugLog('State limited to 2 characters', 'info');
                        }
                        if (fieldId === 'edit_locationZipcode' && this.value.length > 5) {
                            this.value = this.value.substring(0, 5);
                            debugLog('Zipcode limited to 5 characters', 'info');
                        }
                        
                        updateEditLiveAddress();
                    });
                    
                    field.addEventListener('blur', function() {
                        // Convert state to uppercase
                        if (fieldId === 'edit_locationState') {
                            this.value = this.value.toUpperCase();
                            updateEditLiveAddress();
                        }
                    });
                }
            });
            
            // Initial address update
            updateEditLiveAddress();
            debugLog('Live address update setup complete for edit form', 'success');
        }
        
        // Handle edit form submission
        async function handleEditLocationSubmit(event) {
            event.preventDefault();
            
            if (!authToken) {
                alert('Please login first');
                return;
            }
            
            const form = event.target;
            const placeId = document.getElementById('edit_place_id').value;
            
            // Collect all form data
            const formData = new FormData(form);
            const locationData = {};
            
            // Debug: Log all FormData entries
            console.log('=== FormData entries ===');
            for (let [key, value] of formData.entries()) {
                console.log(`FormData[${key}]:`, value);
            }
            console.log('=== End FormData entries ===');
            
            // Convert FormData to object
            for (let [key, value] of formData.entries()) {
                if (key !== 'place_id') { // Don't include place_id in update data
                    locationData[key] = value || null;
                }
            }
            
            console.log('BEFORE formatted_address override:', locationData.formatted_address);
            
            // Ensure formatted_address is updated from parsed address components
            const addressComponents = {
                number: locationData.number || '',
                street: locationData.street || '',
                city: locationData.city || '',
                state: locationData.state || '',
                zipcode: locationData.zipcode || ''
            };
            
            // Update formatted_address using the same logic as live preview
            const updatedFormattedAddress = formatLiveAddress(addressComponents);
            if (updatedFormattedAddress) {
                console.log('SETTING formatted_address to:', updatedFormattedAddress);
                locationData.formatted_address = updatedFormattedAddress;
                console.log('AFTER setting formatted_address:', locationData.formatted_address);
                debugLog('handleEditLocationSubmit()=======');
                debugLog('Updated formatted_address from components: ' + updatedFormattedAddress, 'info');
                
                console.log('handleEditLocationSubmit()=======');
                console.log('NEW === formatted_address: ', updatedFormattedAddress);
                console.log('NEW formatted_address: ', locationData.formatted_address);
            } else {
                console.log('NO updatedFormattedAddress generated!');
                console.log('addressComponents:', addressComponents);
            }
            
            debugLog('Submitting location update for place_id: ' + placeId, 'info');
            debugLog('Update data: ' + JSON.stringify(locationData), 'info');
            console.log('handleEditLocationSubmit()=======');
            console.log('Submitting location update for place_id: ' + placeId, 'info');
            console.log('Update data: ' + JSON.stringify(locationData), 'info');
            
            console.log('handleEditLocationSubmit()===BEFORE TRY WRITING TO DB ====');

            try {
                const response = await fetch(`http://localhost:3000/api/locations/${placeId}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(locationData)
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    debugLog('Location updated successfully: ' + JSON.stringify(result), 'success');
                    console.log('Update data OK : ' + JSON.stringify(locationData), 'info');
                    
                    // Upload pending photos if any
                    if (window.pendingEditPhotos && window.pendingEditPhotos.length > 0) {
                        try {
                            debugLog('Uploading pending photos...', 'info');
                            for (const photo of window.pendingEditPhotos) {
                                await uploadPhoto(placeId, photo);
                            }
                            debugLog(`${window.pendingEditPhotos.length} photos uploaded successfully`, 'success');
                            window.pendingEditPhotos = []; // Clear pending photos
                        } catch (photoError) {
                            debugLog('Photo upload failed: ' + photoError.message, 'error');
                            // Don't fail the entire save for photo upload issues
                            alert('Location updated successfully, but photo upload failed: ' + photoError.message);
                        }
                    }
                    
                    alert('Location updated successfully!');
                    closeEditModal();
                    refreshLocations(); // Refresh the locations list and markers
                } else {
                    debugLog('Failed to update location: ' + JSON.stringify(result), 'error');
                    alert('Failed to update location: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                debugLog('Error updating location: ' + error.message, 'error');
                alert('Error updating location: ' + error.message);
            }
        }
        
        // Generate comprehensive location form HTML (exactly matching the save form)
        function generateLocationFormHTML(location = {}) {
            return `
                <div class="address-display" id="editLocationAddress" style="background: #f8f9fa; border: 2px solid #dee2e6; border-radius: 8px; padding: 15px; margin-bottom: 20px; font-size: 16px; font-weight: bold; color: #495057; min-height: 20px; transition: all 0.3s ease;">
                    ${escapeHtml(location.formatted_address || 'Address will appear here...')}
                </div>
                
                <!-- Name Field - Required, defaults to street + city -->
                <div class="form-group">
                    <label for="edit_locationName">Location Name *</label>
                    <input type="text" id="edit_locationName" name="name" required maxlength="100" value="${escapeHtml(location.name || '')}" placeholder="Will default to street + city">
                </div>
                
                <!-- Address Components - User can edit before save -->
                <div class="form-group">
                    <label for="edit_locationNumber">Street Number</label>
                    <input type="text" id="edit_locationNumber" name="number" value="${escapeHtml(location.number || '')}" placeholder="3375">
                </div>
                
                <div class="form-group">
                    <label for="edit_locationStreet">Street</label>
                    <input type="text" id="edit_locationStreet" name="street" value="${escapeHtml(location.street || '')}" placeholder="Laren Lane Southwest">
                </div>
                
                <div class="form-group">
                    <label for="edit_locationCity">City</label>
                    <input type="text" id="edit_locationCity" name="city" value="${escapeHtml(location.city || '')}" placeholder="Atlanta">
                </div>
                
                <div class="form-group">
                    <label for="edit_locationState">State</label>
                    <input type="text" id="edit_locationState" name="state" maxlength="2" value="${escapeHtml(location.state || '')}" placeholder="GA">
                </div>
                
                <div class="form-group">
                    <label for="edit_locationZipcode">Zip Code</label>
                    <input type="text" id="edit_locationZipcode" name="zipcode" maxlength="5" value="${escapeHtml(location.zipcode || '')}" placeholder="30311">
                </div>
                
                <!-- Production Notes -->
                <div class="form-group">
                    <label for="edit_productionNotes">Production Notes</label>
                    <textarea id="edit_productionNotes" name="production_notes" maxlength="200" placeholder="Additional notes about this location..." rows="3">${escapeHtml(location.production_notes || '')}</textarea>
                    <small class="char-count">0/200 characters</small>
                </div>
                
                <!-- Type - Required dropdown -->
                <div class="form-group">
                    <label for="edit_locationType">Type *</label>
                    <select id="edit_locationType" name="type" required>
                        <option value="">Select type...</option>
                        <option value="broll" ${location.type === 'broll' ? 'selected' : ''}>B-Roll</option>
                        <option value="interview" ${location.type === 'interview' ? 'selected' : ''}>Interview</option>
                        <option value="live anchor" ${location.type === 'live anchor' ? 'selected' : ''}>Live Anchor</option>
                        <option value="live reporter" ${location.type === 'live reporter' ? 'selected' : ''}>Live Reporter</option>
                        <option value="stakeout" ${location.type === 'stakeout' ? 'selected' : ''}>Stakeout</option>
                    </select>
                </div>
                
                <!-- Entry Point -->
                <div class="form-group">
                    <label for="edit_entryPoint">Entry Point</label>
                    <select id="edit_entryPoint" name="entry_point">
                        <option value="">Select entry point...</option>
                        <option value="front door" ${location.entry_point === 'front door' ? 'selected' : ''}>Front Door</option>
                        <option value="backdoor" ${location.entry_point === 'backdoor' ? 'selected' : ''}>Back Door</option>
                        <option value="garage" ${location.entry_point === 'garage' ? 'selected' : ''}>Garage</option>
                        <option value="parking lot" ${location.entry_point === 'parking lot' ? 'selected' : ''}>Parking Lot</option>
                    </select>
                </div>
                
                <!-- Parking -->
                <div class="form-group">
                    <label for="edit_parking">Parking</label>
                    <select id="edit_parking" name="parking">
                        <option value="">Select parking...</option>
                        <option value="street" ${location.parking === 'street' ? 'selected' : ''}>Street</option>
                        <option value="driveway" ${location.parking === 'driveway' ? 'selected' : ''}>Driveway</option>
                        <option value="garage" ${location.parking === 'garage' ? 'selected' : ''}>Garage</option>
                    </select>
                </div>
                
                <!-- Access -->
                <div class="form-group">
                    <label for="edit_access">Access</label>
                    <select id="edit_access" name="access">
                        <option value="">Select access...</option>
                        <option value="ramp" ${location.access === 'ramp' ? 'selected' : ''}>Ramp</option>
                        <option value="stairs only" ${location.access === 'stairs only' ? 'selected' : ''}>Stairs Only</option>
                        <option value="doorway" ${location.access === 'doorway' ? 'selected' : ''}>Doorway</option>
                        <option value="garage" ${location.access === 'garage' ? 'selected' : ''}>Garage</option>
                    </select>
                </div>
                
                <!-- Photos Section -->
                <div class="form-group">
                    <div class="photos-header">
                        <label>Photos</label>
                        <button type="button" class="photo-toggle-btn" onclick="togglePhotoUpload('edit')">
                            <span class="toggle-text">Add Photos</span>
                        </button>
                    </div>
                    
                    <!-- Existing Photos Display -->
                    <div id="edit-photos-grid" class="photos-grid">
                        <!-- Photos will be loaded here -->
                    </div>
                    
                    <!-- Photo Upload Section (Initially Hidden) -->
                    <div id="edit-photo-upload" class="photo-upload-section" style="display: none;">
                        <div class="upload-area" 
                             ondrop="handlePhotoDrop(event, 'edit')" 
                             ondragover="allowDrop(event)"
                             onclick="document.getElementById('edit-photo-file').click()">
                            <div class="upload-text">
                                <i class="fas fa-camera"></i>
                                <p>Click to select or drag photos here</p>
                                <small>JPG, PNG up to 10MB each</small>
                            </div>
                            <input type="file" 
                                   id="edit-photo-file" 
                                   accept="image/jpeg,image/png" 
                                   multiple 
                                   style="display: none;" 
                                   onchange="handlePhotoFile(event, 'edit')">
                        </div>
                        <div id="edit-photo-preview" class="photo-preview"></div>
                    </div>
                </div>
                
                <!-- Hidden fields for coordinates and place_id -->
                <input type="hidden" id="edit_locationLat" name="lat" value="${location.lat || ''}">
                <input type="hidden" id="edit_locationLng" name="lng" value="${location.lng || ''}">
                <input type="hidden" id="edit_locationPlaceId" name="place_id" value="${location.place_id || ''}">
                <input type="hidden" id="edit_formattedAddress" name="formatted_address" value="${escapeHtml(location.formatted_address || '')}">
            `;
        }
        
        // Delete location
        window.deleteLocation = async function(placeId) {
            if (!authToken) {
                alert('Please login first');
                return;
            }
            
            if (!confirm('Are you sure you want to delete this location?')) {
                return;
            }
            
            debugLog('Deleting location: ' + placeId, 'info');
            
            try {
                const response = await fetch(`http://localhost:3000/api/locations/${placeId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    debugLog('Location deleted successfully', 'success');
                    await loadSavedLocations(); // This will refresh both list and markers
                } else {
                    const error = await response.json();
                    debugLog('Error deleting location: ' + error.error, 'error');
                    alert('Error deleting location: ' + error.error);
                }
            } catch (error) {
                debugLog('Error deleting location: ' + error.message, 'error');
                alert('Error deleting location: ' + error.message);
            }
        };
        
        // Refresh locations
        window.refreshLocations = async function() {
            await loadSavedLocations();
        };
        
        // Clear debug log
        window.clearDebugLog = function() {
            const logDiv = document.getElementById('debugLog');
            if (logDiv) {
                logDiv.innerHTML = '<div class="debug-entry info">Debug log cleared</div>';
            }
        };
        
        // Utility function to read out any data object
        function dataReadout(data, objectName = 'Data Object', maxDepth = 3) {
            debugLog(`=== ${objectName.toUpperCase()} READOUT ===`, 'info');
            
            // Basic info about the object
            debugLog(`Type: ${typeof data}`, 'info');
            debugLog(`Constructor: ${data?.constructor?.name || 'Unknown'}`, 'info');
            
            if (data === null || data === undefined) {
                debugLog(`Value: ${data}`, 'info');
                debugLog(`=== END ${objectName.toUpperCase()} READOUT ===`, 'info');
                return;
            }
            
            // For arrays
            if (Array.isArray(data)) {
                debugLog(`Array length: ${data.length}`, 'info');
                debugLog('Full array JSON:', 'info');
                debugLog(JSON.stringify(data, null, 2), 'info');
                
                if (data.length > 0) {
                    debugLog('--- FIRST ITEM BREAKDOWN ---', 'info');
                    dataReadoutItem(data[0], 'First Item', 1, maxDepth);
                    
                    if (data.length > 1) {
                        debugLog('--- ALL ITEMS SUMMARY ---', 'info');
                        data.forEach((item, index) => {
                            if (typeof item === 'object' && item !== null) {
                                const summary = Object.keys(item).map(key => 
                                    `${key}=${JSON.stringify(item[key])}`
                                ).join(', ');
                                debugLog(`Item ${index + 1}: {${summary}}`, 'info');
                            } else {
                                debugLog(`Item ${index + 1}: ${JSON.stringify(item)}`, 'info');
                            }
                        });
                    }
                }
            }
            // For objects
            else if (typeof data === 'object') {
                debugLog('Full object JSON:', 'info');
                debugLog(JSON.stringify(data, null, 2), 'info');
                dataReadoutItem(data, objectName, 1, maxDepth);
            }
            // For primitives
            else {
                debugLog(`Value: ${JSON.stringify(data)}`, 'info');
            }
            
            debugLog(`=== END ${objectName.toUpperCase()} READOUT ===`, 'info');
        }
        
        // Helper function for recursive object breakdown
        function dataReadoutItem(item, itemName, currentDepth, maxDepth) {
            if (currentDepth > maxDepth || item === null || item === undefined) {
                return;
            }
            
            debugLog(`--- ${itemName} Properties ---`, 'info');
            Object.keys(item).forEach(key => {
                const value = item[key];
                const type = typeof value;
                
                if (value === null || value === undefined) {
                    debugLog(`${key}: ${value} (${type})`, 'info');
                } else if (Array.isArray(value)) {
                    debugLog(`${key}: [Array with ${value.length} items] (${type})`, 'info');
                    if (currentDepth < maxDepth && value.length > 0) {
                        debugLog(`${key}[0]: ${JSON.stringify(value[0])}`, 'info');
                    }
                } else if (type === 'object') {
                    debugLog(`${key}: [Object] (${type})`, 'info');
                    if (currentDepth < maxDepth) {
                        dataReadoutItem(value, `${key}`, currentDepth + 1, maxDepth);
                    }
                } else {
                    debugLog(`${key}: ${JSON.stringify(value)} (${type})`, 'info');
                }
            });
        }
        
        // Show data readout function - can be called manually
        window.showDataReadout = async function() {
            debugLog('Manually triggering data readout...', 'info');
            try {
                const response = await fetch('http://localhost:3000/api/locations/with-creators');
                const data = await response.json();
                dataReadout(data, 'API Response');
            } catch (error) {
                debugLog('Error in manual data readout: ' + error.message, 'error');
            }
        };
        
        // Escape HTML
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Close modal when clicking outside
        window.addEventListener('click', function(event) {
            const saveModal = document.getElementById('saveLocationModal');
            const editModal = document.getElementById('editLocationModal');
            
            if (event.target === saveModal) {
                closeSaveModal();
            }
            
            if (event.target === editModal) {
                closeEditModal();
            }
        });
    </script>
</body>
</html>
